{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Iridescence a light-weight visualization library for rapid prototyping of 3D algorithms. This library is designed for accelerating personal research and development projects (mainly focusing on point-cloud-related algorithms) and is NOT intended to be a general-purpose visualization library with rich rendering capabilities. on Ubuntu 18.04 / 20.04 / 22.04 Features What this library provides: An easy-to-use 3D visualization framework (inpaticular suitable for rendering point clouds) Tightly integrated Dear ImGui interfaces for rapid UI design What this library does NOT provide: Realistic rendering and shading Rich textured 3D mesh rendering Dependencies GLFW ( zlib/libpng license ) gl3w ( Public domain ) Dear ImGui ( MIT license ) ImGuizmo ( MIT license ) implot ( MIT license ) Eigen ( MPL2 license ) portable-file-dialogs ( WTFPL license ) Installation # Install dependencies sudo apt-get install -y libglm-dev libglfw3-dev libpng-dev libjpeg-dev libeigen3-dev # Build and install Iridescence git clone https://github.com/koide3/iridescence mkdir iridescence/build && cd iridescence/build cmake .. make -j sudo make install # [Optional] Build and install python bindings cd .. sudo python3 setup.py install # [Optional2] Install stubs for autocomplete pip install pybind11-stubgen cd ~/.local/lib/python3.10/site-packages pybind11-stubgen -o . --ignore-invalid = all pyridescence Docker Build: docker build -t iridescence -f docker/ubuntu/Dockerfile . Run: bash docker/run.sh iridescence Use Iridescence in your cmake project # Add FindIridescence.cmake to your project wget -P path/to/your_project/cmake/ https://github.com/koide3/iridescence/raw/master/cmake/FindIridescence.cmake # Make FindIridescence.cmake visible to your cmake project set ( CMAKE_MODULE_PATH ${ CMAKE_MODULE_PATH } \"${CMAKE_CURRENT_LIST_DIR}/cmake\" ) # Find package find_package ( Iridescence REQUIRED ) # Add include dirs and link libraries target_include_directories ( your_program PUBLIC ${ Iridescence_INCLUDE_DIRS } ) target_link_libraries ( your_program ${ Iridescence_LIBRARIES } ) Minimum example C++: #include <glk/primitives/primitives.hpp> #include <guik/viewer/light_viewer.hpp> int main ( int argc , char ** argv ) { // Create a viewer instance (global singleton) auto viewer = guik :: LightViewer :: instance (); float angle = 0.0f ; // Register a callback for UI rendering viewer -> register_ui_callback ( \"ui\" , [ & ]() { // In the callback, you can call ImGui commands to create your UI. // Here, we use \"DragFloat\" and \"Button\" to create a simple UI. ImGui :: DragFloat ( \"Angle\" , & angle , 0.01f ); if ( ImGui :: Button ( \"Close\" )) { viewer -> close (); } }); // Spin the viewer until it gets closed while ( viewer -> spin_once ()) { // Objects to be rendered are called \"drawables\" and managed with unique names. // Here, solid and wire spheres are registered to the viewer respectively with the \"Rainbow\" and \"FlatColor\" coloring schemes. // The \"Rainbow\" coloring scheme encodes the height of each fragment using the turbo colormap by default. Eigen :: AngleAxisf transform ( angle , Eigen :: Vector3f :: UnitZ ()); viewer -> update_drawable ( \"sphere\" , glk :: Primitives :: sphere (), guik :: Rainbow ( transform )); viewer -> update_drawable ( \"wire_sphere\" , glk :: Primitives :: wire_sphere (), guik :: FlatColor ({ 0.1f , 0.7f , 1.0f , 1.0f }, transform )); } return 0 ; } Python version #!/usr/bin/python3 import numpy from scipy.spatial.transform import Rotation from pyridescence import * # Create a viewer instance (global singleton) viewer = guik . LightViewer . instance () angle = 0.0 # Define a callback for UI rendering def ui_callback (): # In the callback, you can call ImGui commands to create your UI. # Here, we use \"DragFloat\" and \"Button\" to create a simple UI. global angle _ , angle = imgui . drag_float ( 'angle' , angle , 0.01 ) if imgui . button ( 'close' ): viewer . close () # Register a callback for UI rendering viewer . register_ui_callback ( 'ui' , ui_callback ) # Spin the viewer until it gets closed while viewer . spin_once (): # Objects to be rendered are called \"drawables\" and managed with unique names. # Here, solid and wire spheres are registered to the viewer respectively with the \"Rainbow\" and \"FlatColor\" coloring schemes. # The \"Rainbow\" coloring scheme encodes the height of each fragment using the turbo colormap by default. transform = numpy . identity ( 4 ) transform [: 3 , : 3 ] = Rotation . from_rotvec ([ 0.0 , 0.0 , angle ]) . as_matrix () viewer . update_drawable ( 'sphere' , glk . primitives . sphere (), guik . Rainbow ( transform )) viewer . update_drawable ( 'wire_sphere' , glk . primitives . wire_sphere (), guik . FlatColor ( 0.1 , 0.7 , 1.0 , 1.0 , transform )) Some use examples in my academic works License This package is released under the MIT license.","title":"Home"},{"location":"#features","text":"What this library provides: An easy-to-use 3D visualization framework (inpaticular suitable for rendering point clouds) Tightly integrated Dear ImGui interfaces for rapid UI design What this library does NOT provide: Realistic rendering and shading Rich textured 3D mesh rendering","title":"Features"},{"location":"#dependencies","text":"GLFW ( zlib/libpng license ) gl3w ( Public domain ) Dear ImGui ( MIT license ) ImGuizmo ( MIT license ) implot ( MIT license ) Eigen ( MPL2 license ) portable-file-dialogs ( WTFPL license )","title":"Dependencies"},{"location":"#installation","text":"# Install dependencies sudo apt-get install -y libglm-dev libglfw3-dev libpng-dev libjpeg-dev libeigen3-dev # Build and install Iridescence git clone https://github.com/koide3/iridescence mkdir iridescence/build && cd iridescence/build cmake .. make -j sudo make install # [Optional] Build and install python bindings cd .. sudo python3 setup.py install # [Optional2] Install stubs for autocomplete pip install pybind11-stubgen cd ~/.local/lib/python3.10/site-packages pybind11-stubgen -o . --ignore-invalid = all pyridescence","title":"Installation"},{"location":"#docker","text":"Build: docker build -t iridescence -f docker/ubuntu/Dockerfile . Run: bash docker/run.sh iridescence","title":"Docker"},{"location":"#use-iridescence-in-your-cmake-project","text":"# Add FindIridescence.cmake to your project wget -P path/to/your_project/cmake/ https://github.com/koide3/iridescence/raw/master/cmake/FindIridescence.cmake # Make FindIridescence.cmake visible to your cmake project set ( CMAKE_MODULE_PATH ${ CMAKE_MODULE_PATH } \"${CMAKE_CURRENT_LIST_DIR}/cmake\" ) # Find package find_package ( Iridescence REQUIRED ) # Add include dirs and link libraries target_include_directories ( your_program PUBLIC ${ Iridescence_INCLUDE_DIRS } ) target_link_libraries ( your_program ${ Iridescence_LIBRARIES } )","title":"Use Iridescence in your cmake project"},{"location":"#minimum-example","text":"C++: #include <glk/primitives/primitives.hpp> #include <guik/viewer/light_viewer.hpp> int main ( int argc , char ** argv ) { // Create a viewer instance (global singleton) auto viewer = guik :: LightViewer :: instance (); float angle = 0.0f ; // Register a callback for UI rendering viewer -> register_ui_callback ( \"ui\" , [ & ]() { // In the callback, you can call ImGui commands to create your UI. // Here, we use \"DragFloat\" and \"Button\" to create a simple UI. ImGui :: DragFloat ( \"Angle\" , & angle , 0.01f ); if ( ImGui :: Button ( \"Close\" )) { viewer -> close (); } }); // Spin the viewer until it gets closed while ( viewer -> spin_once ()) { // Objects to be rendered are called \"drawables\" and managed with unique names. // Here, solid and wire spheres are registered to the viewer respectively with the \"Rainbow\" and \"FlatColor\" coloring schemes. // The \"Rainbow\" coloring scheme encodes the height of each fragment using the turbo colormap by default. Eigen :: AngleAxisf transform ( angle , Eigen :: Vector3f :: UnitZ ()); viewer -> update_drawable ( \"sphere\" , glk :: Primitives :: sphere (), guik :: Rainbow ( transform )); viewer -> update_drawable ( \"wire_sphere\" , glk :: Primitives :: wire_sphere (), guik :: FlatColor ({ 0.1f , 0.7f , 1.0f , 1.0f }, transform )); } return 0 ; } Python version #!/usr/bin/python3 import numpy from scipy.spatial.transform import Rotation from pyridescence import * # Create a viewer instance (global singleton) viewer = guik . LightViewer . instance () angle = 0.0 # Define a callback for UI rendering def ui_callback (): # In the callback, you can call ImGui commands to create your UI. # Here, we use \"DragFloat\" and \"Button\" to create a simple UI. global angle _ , angle = imgui . drag_float ( 'angle' , angle , 0.01 ) if imgui . button ( 'close' ): viewer . close () # Register a callback for UI rendering viewer . register_ui_callback ( 'ui' , ui_callback ) # Spin the viewer until it gets closed while viewer . spin_once (): # Objects to be rendered are called \"drawables\" and managed with unique names. # Here, solid and wire spheres are registered to the viewer respectively with the \"Rainbow\" and \"FlatColor\" coloring schemes. # The \"Rainbow\" coloring scheme encodes the height of each fragment using the turbo colormap by default. transform = numpy . identity ( 4 ) transform [: 3 , : 3 ] = Rotation . from_rotvec ([ 0.0 , 0.0 , angle ]) . as_matrix () viewer . update_drawable ( 'sphere' , glk . primitives . sphere (), guik . Rainbow ( transform )) viewer . update_drawable ( 'wire_sphere' , glk . primitives . wire_sphere (), guik . FlatColor ( 0.1 , 0.7 , 1.0 , 1.0 , transform ))","title":"Minimum example"},{"location":"#some-use-examples-in-my-academic-works","text":"","title":"Some use examples in my academic works"},{"location":"#license","text":"This package is released under the MIT license.","title":"License"},{"location":"basic/","text":"Basic usage Creating a viewer instance guik::LightViewer::instance() creates and returns a global viewer instance. The viewer instance is created on the first call, and results of guik::LightViewer::instance() refer to the same globally singular instance (i.e., singleton pattern). viewer->spin_once() updates viewer contents and renders a frame on the window. It returns false when the viewer window is closed. The following code is a minimum example to show a blank viewer window. #include <guik/viewer/light_viewer.hpp> int main ( int argc , char ** argv ) { // Create a global viewer instance auto viewer = guik :: LightViewer :: instance (); // Spin the viewer until the window gets closed while ( viewer -> spin_once ()) {} } Instead of calling spin_once() in a while loop, you can also use spin() that spins the viewer until the windows gets closed. viewer -> spin (); // The above is equivalent to the below while ( viewer -> spin_once ()) {} There is also a shorthand function guik::viewer() that is equivalent to guik::LightViewer::instance() . auto viewer = guik :: viewer (); // Equivalent to guik::LightViewer::instance() With these convenient functions, the minimum example can be rewritten in a shorter form. #include <guik/viewer/light_viewer.hpp> int main ( int argc , char ** argv ) { auto viewer = guik :: viewer (); viewer -> spin (); } Registering drawables to the viewer 3D objects to be drawn are called drawables and managed with unique names (or IDs). The following code shows a minimum example to register a wire sphere to the viewer. #include <glk/primitives/primitives.hpp> #include <guik/viewer/light_viewer.hpp> int main ( int argc , char ** argv ) { auto viewer = guik :: viewer (); // Register a wire sphere drawable with the name \"sphere\" // and the flat red coloring setting. viewer -> update_drawable ( \"sphere\" , glk :: Primitives :: wire_sphere (), guik :: FlatRed () ); viewer -> spin (); } The first argument of update_drawable() is a name to be assigned to the drawable. If the name already exists, the viewer overwrites the existing drawable with the new one. The second argument is a drawable to be registered. Take a look at Drawables to see supported 3D drawable types. The third argument is a shader setting to hold rendering parameters. By changing shader setting parameters, you can control the color, pose, and shape of drawables as shown in below: auto transformation1 = Eigen :: Translation3f ( 0.0f , -2.0f , 0.0f ); auto setting1 = guik :: Rainbow ( transformation1 ); viewer -> update_drawable ( \"sphere1\" , glk :: Primitives :: wire_sphere (), setting1 ); auto transformation2 = Eigen :: Translation3f ( 0.0f , 2.0f , 0.0f ); auto setting2 = guik :: FlatColor ({ 1.0f , 0.5f , 0.2f , 1.0f }, transformation2 ); viewer -> update_drawable ( \"sphere2\" , glk :: Primitives :: wire_sphere (), setting2 ); See Shader setting for more details. Tip There are shorthand functions (e.g., update_sphere ) for frequently used drawable types that allow registering drawables without including additional headers. // Register a solid sphere viewer -> update_sphere ( \"sphere\" , guik :: FlatRed ()); Tip ShaderSetting class has several utility methods for handy manipulation of the model matrix. // Register a solid sphere with translation and scaling viewer -> update_sphere ( \"sphere\" , guik :: FlatRed ()). translate ({ 1.0 , 2.0 , 3.0 }). scale ( 0.1 ); Registering UI callbacks (Dear ImGui) Research and development often involve trial-and-error processes with many parameter settings that often take a large amount of effort. To accelerate such development processes, Iridescence provides tightly integrated interfaces to Dear ImGui , an immediate mode GUI library that enables designing interactive user interfaces easily and rapidly. To create a ImGui-based GUI, register a callback function for UI rendering events using register_ui_callback() . In the following example, we create a simple GUI with DragFloat to rotate a sphere, and Button to close the viewer window. #include <glk/primitives/primitives.hpp> #include <guik/viewer/light_viewer.hpp> int main ( int argc , char ** argv ) { auto viewer = guik :: viewer (); float angle = 0.0f ; // Register a callback for UI rendering with the name \"ui_callback\". viewer -> register_ui_callback ( \"ui_callback\" , [ & ]() { // In the callback, you can call ImGui commands to create your UI. ImGui :: DragFloat ( \"Angle\" , & angle , 0.01f ); if ( ImGui :: Button ( \"Close\" )) { viewer -> close (); } }); while ( viewer -> spin_once ()) { // Show rotated solid and wire spheres. viewer -> update_drawable ( \"sphere\" , glk :: Primitives :: sphere (), guik :: Rainbow (). rotate ( angle , { 0.0f , 0.0f , 1.0f })); viewer -> update_drawable ( \"wire_sphere\" , glk :: Primitives :: wire_sphere (), guik :: FlatColor ( 0.1f , 0.7f , 1.0f , 1.0f ). rotate ( angle , { 0.0f , 0.0f , 1.0f })); } return 0 ; } See Dear ImGui for details of the GUI library. Note In addition to Dear ImGui, several libraries ( implot , ImGuizmo , and portable-file-dialogs ) are bundled for rapid prototyping.","title":"Basic usage"},{"location":"basic/#basic-usage","text":"","title":"Basic usage"},{"location":"basic/#creating-a-viewer-instance","text":"guik::LightViewer::instance() creates and returns a global viewer instance. The viewer instance is created on the first call, and results of guik::LightViewer::instance() refer to the same globally singular instance (i.e., singleton pattern). viewer->spin_once() updates viewer contents and renders a frame on the window. It returns false when the viewer window is closed. The following code is a minimum example to show a blank viewer window. #include <guik/viewer/light_viewer.hpp> int main ( int argc , char ** argv ) { // Create a global viewer instance auto viewer = guik :: LightViewer :: instance (); // Spin the viewer until the window gets closed while ( viewer -> spin_once ()) {} } Instead of calling spin_once() in a while loop, you can also use spin() that spins the viewer until the windows gets closed. viewer -> spin (); // The above is equivalent to the below while ( viewer -> spin_once ()) {} There is also a shorthand function guik::viewer() that is equivalent to guik::LightViewer::instance() . auto viewer = guik :: viewer (); // Equivalent to guik::LightViewer::instance() With these convenient functions, the minimum example can be rewritten in a shorter form. #include <guik/viewer/light_viewer.hpp> int main ( int argc , char ** argv ) { auto viewer = guik :: viewer (); viewer -> spin (); }","title":"Creating a viewer instance"},{"location":"basic/#registering-drawables-to-the-viewer","text":"3D objects to be drawn are called drawables and managed with unique names (or IDs). The following code shows a minimum example to register a wire sphere to the viewer. #include <glk/primitives/primitives.hpp> #include <guik/viewer/light_viewer.hpp> int main ( int argc , char ** argv ) { auto viewer = guik :: viewer (); // Register a wire sphere drawable with the name \"sphere\" // and the flat red coloring setting. viewer -> update_drawable ( \"sphere\" , glk :: Primitives :: wire_sphere (), guik :: FlatRed () ); viewer -> spin (); } The first argument of update_drawable() is a name to be assigned to the drawable. If the name already exists, the viewer overwrites the existing drawable with the new one. The second argument is a drawable to be registered. Take a look at Drawables to see supported 3D drawable types. The third argument is a shader setting to hold rendering parameters. By changing shader setting parameters, you can control the color, pose, and shape of drawables as shown in below: auto transformation1 = Eigen :: Translation3f ( 0.0f , -2.0f , 0.0f ); auto setting1 = guik :: Rainbow ( transformation1 ); viewer -> update_drawable ( \"sphere1\" , glk :: Primitives :: wire_sphere (), setting1 ); auto transformation2 = Eigen :: Translation3f ( 0.0f , 2.0f , 0.0f ); auto setting2 = guik :: FlatColor ({ 1.0f , 0.5f , 0.2f , 1.0f }, transformation2 ); viewer -> update_drawable ( \"sphere2\" , glk :: Primitives :: wire_sphere (), setting2 ); See Shader setting for more details. Tip There are shorthand functions (e.g., update_sphere ) for frequently used drawable types that allow registering drawables without including additional headers. // Register a solid sphere viewer -> update_sphere ( \"sphere\" , guik :: FlatRed ()); Tip ShaderSetting class has several utility methods for handy manipulation of the model matrix. // Register a solid sphere with translation and scaling viewer -> update_sphere ( \"sphere\" , guik :: FlatRed ()). translate ({ 1.0 , 2.0 , 3.0 }). scale ( 0.1 );","title":"Registering drawables to the viewer"},{"location":"basic/#registering-ui-callbacks-dear-imgui","text":"Research and development often involve trial-and-error processes with many parameter settings that often take a large amount of effort. To accelerate such development processes, Iridescence provides tightly integrated interfaces to Dear ImGui , an immediate mode GUI library that enables designing interactive user interfaces easily and rapidly. To create a ImGui-based GUI, register a callback function for UI rendering events using register_ui_callback() . In the following example, we create a simple GUI with DragFloat to rotate a sphere, and Button to close the viewer window. #include <glk/primitives/primitives.hpp> #include <guik/viewer/light_viewer.hpp> int main ( int argc , char ** argv ) { auto viewer = guik :: viewer (); float angle = 0.0f ; // Register a callback for UI rendering with the name \"ui_callback\". viewer -> register_ui_callback ( \"ui_callback\" , [ & ]() { // In the callback, you can call ImGui commands to create your UI. ImGui :: DragFloat ( \"Angle\" , & angle , 0.01f ); if ( ImGui :: Button ( \"Close\" )) { viewer -> close (); } }); while ( viewer -> spin_once ()) { // Show rotated solid and wire spheres. viewer -> update_drawable ( \"sphere\" , glk :: Primitives :: sphere (), guik :: Rainbow (). rotate ( angle , { 0.0f , 0.0f , 1.0f })); viewer -> update_drawable ( \"wire_sphere\" , glk :: Primitives :: wire_sphere (), guik :: FlatColor ( 0.1f , 0.7f , 1.0f , 1.0f ). rotate ( angle , { 0.0f , 0.0f , 1.0f })); } return 0 ; } See Dear ImGui for details of the GUI library. Note In addition to Dear ImGui, several libraries ( implot , ImGuizmo , and portable-file-dialogs ) are bundled for rapid prototyping.","title":"Registering UI callbacks (Dear ImGui)"},{"location":"controls/","text":"Camera and model controls Camera control auto viewer = guik :: LightViewer :: instance (); // Use a camera control that moves along with the XY-plane viewer -> use_orbit_camera_control (); // Use a camera control that moves along with the XZ-plane viewer -> use_orbit_camera_control_xz (); // Use a top-down camera control facing to the XY-plane viewer -> use_topdown_camera_control (); // Use an arcball-like camera control that can make an arbitrary pose viewer -> use_arcball_camera_control (); // Use an FPS-like camera control with keyboard (WASD) control viewer -> use_fps_camera_control (); A useful method to let the camera keep focusing on a moving object is lookat() that moves the camera such that the specified position comes to the center of the camera view. Eigen :: Vector3f center_pos = ...; viewer -> lookat ( center_pos ); lookat example (0:13 ~) Keyboard control Key Description Ctrl + Arrow Move camera Ctrl + Page UP / Down Zoom in/out Ctrl + Home / End Increase / decrease moving speed (permanently) Shift Increase moving speed (while holding) FPS-camera control Key Description W / A / S / D Forward / Left / Backward / Right R / F Up / Down E / Q Heading (Yaw rotation) Mouse Description Hold left button Yaw / Pitch rotation Hold right button Up / Down Hold scroll button Forward / Backward / Left/ Right Scroll Change FOV Implementing custom camera control In case you want to directly control the camera properties, use StaticCameraControl and StaticProjectionControl . This combination enables, for example, AR-like visualization through direct manipulation of camera pose and projection. Eigen :: Isometry3f T_world_camera = ...; // Camera pose (X = right, Y = down, Z = forward) auto static_camera = std :: make_shared < guik :: StaticCameraControl > ( T_world_camera ); viewer -> set_camera_control ( static_camera ); Eigen :: Vector2i canvas_size = viewer -> canvas_size (); Eigen :: Matrix3f camera_matrix = ...; // OpenCV camera intrinsic matrix [[fx, 0, cx], [0, fy, cy], [0, 0, 1]] auto static_projection = std :: make_shared < guik :: StaticProjectionControl > ( canvas_size , camera_matrix ); viewer -> set_projection_control ( static_projection ); Model matrix control (ImGuizmo) #include <guik/model_control.hpp> Eigen :: Matrix4f init_model_matrix = Eigen :: Matrix4f :: Identity (); guik :: ModelControl model_control ( \"model_control\" , init_model_matrix ); viewer -> register_ui_callback ( \"model_control_ui\" , [ & ]{ model_control . draw_gizmo_ui (); model_control . draw_gizmo (); Eigen :: Matrix4f model_matrix = model_control . model_matrix (); viewer -> update_drawable ( \"cube\" , glk :: Primitives :: cube (), guik :: Rainbow ( model_matrix )); }); Note: ImGuizmo cannot be shown twice or more in one rendering frame. Guizmo can be drawn on subviewers. auto sub = viewer -> sub_viewer ( \"sub\" ); auto model_control = std :: make_shared < guik :: ModelControl > ( \"model_control\" ); sub -> register_ui_callback ( \"model_control\" , [ = ] { const ImVec2 canvas_rect_min = ImGui :: GetItemRectMin (); const ImVec2 canvas_rect_max = ImGui :: GetItemRectMax (); const int win_x = canvas_rect_min . x ; const int win_y = canvas_rect_min . y ; const int win_w = canvas_rect_max . x - canvas_rect_min . x ; const int win_h = canvas_rect_max . y - canvas_rect_min . y ; const Eigen :: Matrix4f view_matrix = sub -> get_camera_control () -> view_matrix (); const Eigen :: Matrix4f projection_matrix = sub -> get_projection_control () -> projection_matrix (); model_control -> draw_gizmo ( win_x , win_y , win_w , win_h , view_matrix , projection_matrix , true ); sub -> update_coord ( \"coord\" , guik :: VertexColor ( model_control -> model_matrix ())); });","title":"Camera and model controls"},{"location":"controls/#camera-and-model-controls","text":"","title":"Camera and model controls"},{"location":"controls/#camera-control","text":"auto viewer = guik :: LightViewer :: instance (); // Use a camera control that moves along with the XY-plane viewer -> use_orbit_camera_control (); // Use a camera control that moves along with the XZ-plane viewer -> use_orbit_camera_control_xz (); // Use a top-down camera control facing to the XY-plane viewer -> use_topdown_camera_control (); // Use an arcball-like camera control that can make an arbitrary pose viewer -> use_arcball_camera_control (); // Use an FPS-like camera control with keyboard (WASD) control viewer -> use_fps_camera_control (); A useful method to let the camera keep focusing on a moving object is lookat() that moves the camera such that the specified position comes to the center of the camera view. Eigen :: Vector3f center_pos = ...; viewer -> lookat ( center_pos ); lookat example (0:13 ~)","title":"Camera control"},{"location":"controls/#keyboard-control","text":"Key Description Ctrl + Arrow Move camera Ctrl + Page UP / Down Zoom in/out Ctrl + Home / End Increase / decrease moving speed (permanently) Shift Increase moving speed (while holding)","title":"Keyboard control"},{"location":"controls/#fps-camera-control","text":"Key Description W / A / S / D Forward / Left / Backward / Right R / F Up / Down E / Q Heading (Yaw rotation) Mouse Description Hold left button Yaw / Pitch rotation Hold right button Up / Down Hold scroll button Forward / Backward / Left/ Right Scroll Change FOV","title":"FPS-camera control"},{"location":"controls/#implementing-custom-camera-control","text":"In case you want to directly control the camera properties, use StaticCameraControl and StaticProjectionControl . This combination enables, for example, AR-like visualization through direct manipulation of camera pose and projection. Eigen :: Isometry3f T_world_camera = ...; // Camera pose (X = right, Y = down, Z = forward) auto static_camera = std :: make_shared < guik :: StaticCameraControl > ( T_world_camera ); viewer -> set_camera_control ( static_camera ); Eigen :: Vector2i canvas_size = viewer -> canvas_size (); Eigen :: Matrix3f camera_matrix = ...; // OpenCV camera intrinsic matrix [[fx, 0, cx], [0, fy, cy], [0, 0, 1]] auto static_projection = std :: make_shared < guik :: StaticProjectionControl > ( canvas_size , camera_matrix ); viewer -> set_projection_control ( static_projection );","title":"Implementing custom camera control"},{"location":"controls/#model-matrix-control-imguizmo","text":"#include <guik/model_control.hpp> Eigen :: Matrix4f init_model_matrix = Eigen :: Matrix4f :: Identity (); guik :: ModelControl model_control ( \"model_control\" , init_model_matrix ); viewer -> register_ui_callback ( \"model_control_ui\" , [ & ]{ model_control . draw_gizmo_ui (); model_control . draw_gizmo (); Eigen :: Matrix4f model_matrix = model_control . model_matrix (); viewer -> update_drawable ( \"cube\" , glk :: Primitives :: cube (), guik :: Rainbow ( model_matrix )); }); Note: ImGuizmo cannot be shown twice or more in one rendering frame. Guizmo can be drawn on subviewers. auto sub = viewer -> sub_viewer ( \"sub\" ); auto model_control = std :: make_shared < guik :: ModelControl > ( \"model_control\" ); sub -> register_ui_callback ( \"model_control\" , [ = ] { const ImVec2 canvas_rect_min = ImGui :: GetItemRectMin (); const ImVec2 canvas_rect_max = ImGui :: GetItemRectMax (); const int win_x = canvas_rect_min . x ; const int win_y = canvas_rect_min . y ; const int win_w = canvas_rect_max . x - canvas_rect_min . x ; const int win_h = canvas_rect_max . y - canvas_rect_min . y ; const Eigen :: Matrix4f view_matrix = sub -> get_camera_control () -> view_matrix (); const Eigen :: Matrix4f projection_matrix = sub -> get_projection_control () -> projection_matrix (); model_control -> draw_gizmo ( win_x , win_y , win_w , win_h , view_matrix , projection_matrix , true ); sub -> update_coord ( \"coord\" , guik :: VertexColor ( model_control -> model_matrix ())); });","title":"Model matrix control (ImGuizmo)"},{"location":"cookbook/","text":"Cookbook Point cloud editor src/example/ext_pointcloud_editor.cpp ext_pointcloud_editor.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include <glk/io/ply_io.hpp> #include <glk/pointcloud_buffer.hpp> #include <glk/indexed_pointcloud_buffer.hpp> #include <glk/primitives/primitives.hpp> #include <guik/model_control.hpp> #include <guik/viewer/light_viewer.hpp> #include <portable-file-dialogs.h> class PointCloudEditor { public : PointCloudEditor () { auto viewer = guik :: LightViewer :: instance (); cube_matrix . reset ( new guik :: ModelControl ( \"cube_matrix\" )); viewer -> register_ui_callback ( \"ui\" , [ this ] { ui_callback (); }); viewer -> spin (); } private : void ui_callback () { auto viewer = guik :: LightViewer :: instance (); ImGui :: Begin ( \"control\" , nullptr , ImGuiWindowFlags_AlwaysAutoResize ); // Load points if ( ImGui :: Button ( \"Load point cloud\" )) { for ( const auto & filename : pfd :: open_file ( \"Select a PLY file\" ). result ()) { // Load points from PLY and add them to the point list auto ply = glk :: load_ply ( filename ); if ( ply ) { points . insert ( points . end (), ply -> vertices . begin (), ply -> vertices . end ()); } } // Show points on the viewer if ( ! points . empty ()) { cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( points ); viewer -> update_drawable ( \"points\" , cloud_buffer , guik :: Rainbow ()); } } // Save points if ( ImGui :: Button ( \"Save point cloud\" )) { auto path = pfd :: save_file ( \"Select a destination path to save PLY\" ). result (); if ( ! path . empty () && ! points . empty ()) { glk :: save_ply_binary ( path , points . data (), points . size ()); } } // Show the cube representing the filtering area ImGui :: Separator (); cube_matrix -> draw_gizmo_ui (); cube_matrix -> draw_gizmo (); viewer -> update_drawable ( \"cube\" , glk :: Primitives :: cube (), guik :: FlatColor ({ 1.0f , 0.5f , 0.0f , 0.5f }, cube_matrix -> model_matrix ()). make_transparent ()); // Find points in the filtering area if ( ImGui :: Button ( \"Select points\" )) { // The inverse of the cube model matrix transforms world points in the cube coordinate system Eigen :: Matrix4f inv_cube_matrix = cube_matrix -> model_matrix (). inverse (); selected_points . clear (); neg_selected_points . clear (); for ( int i = 0 ; i < points . size (); i ++ ) { Eigen :: Vector3f pt = ( Eigen :: Affine3f ( inv_cube_matrix ) * points [ i ]); // Points in [(-0.5, -0.5, -0.5), (0.5, 0.5, 0.5)] are inside of the cube if (( pt . array () > Eigen :: Array3f :: Constant ( -0.5f )). all () && ( pt . array () < Eigen :: Array3f :: Constant ( 0.5f )). all ()) { selected_points . emplace_back ( i ); } else { neg_selected_points . emplace_back ( i ); } } // Show the selected points with large orange points viewer -> update_drawable ( \"selected\" , std :: make_shared < glk :: IndexedPointCloudBuffer > ( cloud_buffer , selected_points ), guik :: FlatOrange (). set_point_scale ( 2.0f )); } // Remove the selected points from the point list if ( ImGui :: Button ( \"Remove points\" )) { // Leave only \"un\"selected points std :: vector < Eigen :: Vector3f > filtered ; std :: transform ( neg_selected_points . begin (), neg_selected_points . end (), std :: back_inserter ( filtered ), [ & ]( const auto i ) { return points [ i ]; }); points = std :: move ( filtered ); selected_points . clear (); neg_selected_points . clear (); cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( points ); viewer -> update_drawable ( \"points\" , cloud_buffer , guik :: Rainbow ()); viewer -> remove_drawable ( \"selected\" ); } ImGui :: End (); } private : std :: unique_ptr < guik :: ModelControl > cube_matrix ; // Model matrix of the cube representing the filtering area std :: vector < Eigen :: Vector3f > points ; // Point cloud std :: shared_ptr < glk :: PointCloudBuffer > cloud_buffer ; // CloudBuffer of points std :: vector < unsigned int > selected_points ; // Selected points std :: vector < unsigned int > neg_selected_points ; // Negative of selected points }; int main ( int argc , char ** argv ) { PointCloudEditor editor ; return 0 ; } PLY file IO with portable-file-dialogs Gizmo-based model matrix control Point cloud rendering using PointCloudBuffer and IndexedPointCloudBuffer","title":"Cookbook"},{"location":"cookbook/#cookbook","text":"","title":"Cookbook"},{"location":"cookbook/#point-cloud-editor","text":"src/example/ext_pointcloud_editor.cpp ext_pointcloud_editor.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include <glk/io/ply_io.hpp> #include <glk/pointcloud_buffer.hpp> #include <glk/indexed_pointcloud_buffer.hpp> #include <glk/primitives/primitives.hpp> #include <guik/model_control.hpp> #include <guik/viewer/light_viewer.hpp> #include <portable-file-dialogs.h> class PointCloudEditor { public : PointCloudEditor () { auto viewer = guik :: LightViewer :: instance (); cube_matrix . reset ( new guik :: ModelControl ( \"cube_matrix\" )); viewer -> register_ui_callback ( \"ui\" , [ this ] { ui_callback (); }); viewer -> spin (); } private : void ui_callback () { auto viewer = guik :: LightViewer :: instance (); ImGui :: Begin ( \"control\" , nullptr , ImGuiWindowFlags_AlwaysAutoResize ); // Load points if ( ImGui :: Button ( \"Load point cloud\" )) { for ( const auto & filename : pfd :: open_file ( \"Select a PLY file\" ). result ()) { // Load points from PLY and add them to the point list auto ply = glk :: load_ply ( filename ); if ( ply ) { points . insert ( points . end (), ply -> vertices . begin (), ply -> vertices . end ()); } } // Show points on the viewer if ( ! points . empty ()) { cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( points ); viewer -> update_drawable ( \"points\" , cloud_buffer , guik :: Rainbow ()); } } // Save points if ( ImGui :: Button ( \"Save point cloud\" )) { auto path = pfd :: save_file ( \"Select a destination path to save PLY\" ). result (); if ( ! path . empty () && ! points . empty ()) { glk :: save_ply_binary ( path , points . data (), points . size ()); } } // Show the cube representing the filtering area ImGui :: Separator (); cube_matrix -> draw_gizmo_ui (); cube_matrix -> draw_gizmo (); viewer -> update_drawable ( \"cube\" , glk :: Primitives :: cube (), guik :: FlatColor ({ 1.0f , 0.5f , 0.0f , 0.5f }, cube_matrix -> model_matrix ()). make_transparent ()); // Find points in the filtering area if ( ImGui :: Button ( \"Select points\" )) { // The inverse of the cube model matrix transforms world points in the cube coordinate system Eigen :: Matrix4f inv_cube_matrix = cube_matrix -> model_matrix (). inverse (); selected_points . clear (); neg_selected_points . clear (); for ( int i = 0 ; i < points . size (); i ++ ) { Eigen :: Vector3f pt = ( Eigen :: Affine3f ( inv_cube_matrix ) * points [ i ]); // Points in [(-0.5, -0.5, -0.5), (0.5, 0.5, 0.5)] are inside of the cube if (( pt . array () > Eigen :: Array3f :: Constant ( -0.5f )). all () && ( pt . array () < Eigen :: Array3f :: Constant ( 0.5f )). all ()) { selected_points . emplace_back ( i ); } else { neg_selected_points . emplace_back ( i ); } } // Show the selected points with large orange points viewer -> update_drawable ( \"selected\" , std :: make_shared < glk :: IndexedPointCloudBuffer > ( cloud_buffer , selected_points ), guik :: FlatOrange (). set_point_scale ( 2.0f )); } // Remove the selected points from the point list if ( ImGui :: Button ( \"Remove points\" )) { // Leave only \"un\"selected points std :: vector < Eigen :: Vector3f > filtered ; std :: transform ( neg_selected_points . begin (), neg_selected_points . end (), std :: back_inserter ( filtered ), [ & ]( const auto i ) { return points [ i ]; }); points = std :: move ( filtered ); selected_points . clear (); neg_selected_points . clear (); cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( points ); viewer -> update_drawable ( \"points\" , cloud_buffer , guik :: Rainbow ()); viewer -> remove_drawable ( \"selected\" ); } ImGui :: End (); } private : std :: unique_ptr < guik :: ModelControl > cube_matrix ; // Model matrix of the cube representing the filtering area std :: vector < Eigen :: Vector3f > points ; // Point cloud std :: shared_ptr < glk :: PointCloudBuffer > cloud_buffer ; // CloudBuffer of points std :: vector < unsigned int > selected_points ; // Selected points std :: vector < unsigned int > neg_selected_points ; // Negative of selected points }; int main ( int argc , char ** argv ) { PointCloudEditor editor ; return 0 ; } PLY file IO with portable-file-dialogs Gizmo-based model matrix control Point cloud rendering using PointCloudBuffer and IndexedPointCloudBuffer","title":"Point cloud editor"},{"location":"drawables/","text":"Drawables Examples of lines, 3D primitives, and 2D drawings ( Code ): Shorthand methods For frequently used drawable types, guik::LightViewer provides shorthand methods to quickly create and update drawables. // Primitives viewer -> update_sphere ( \"sphere\" , guik :: FlatRed ()); viewer -> update_wire_sphere ( \"wire_sphere\" , guik :: FlatRed ()); viewer -> update_coord ( \"coord\" , guik :: VertexColor ()); viewer -> update_wire_frustum ( \"frustum\" , guik :: FlatGreen ()); // PointCloudBuffer // Any of Vector(3|4)(f|d) are allowed as input std :: vector < Eigen :: Vector4d > points = ...; viewer -> update_points ( \"points\" , points , guik :: Rainbow ()); // NormalDistributions std :: vector < Eigen :: Vector3f > means = ...; std :: vector < Eigen :: Matrix3f > covs = ...; float scale = 1.0f ; viewer -> update_normal_dists ( \"normal_dists\" , means , covs , scale , guik :: Rainbow ());) // ThinLine std :: vector < Eigen :: Vector3f > line_vertices = ...; bool line_strip = true ; viewer -> update_thin_lines ( \"lines\" , line_vertices , true , guik :: FlatGreen ()); 3D Primitives Icosahedron Sphere Stanford bunny Cube Cone Coordinate system Frustum #include <glk/primitives/primitives.hpp> // Solid and wire icosahedrons glk :: Primitives :: icosahedron (); glk :: Primitives :: wire_icosahedron (); // Solid and wire spheres glk :: Primitives :: sphere (); glk :: Primitives :: wire_sphere (); // Solid and wire bunnies glk :: Primitives :: bunny (); glk :: Primitives :: wire_bunny (); // Solid and wire cubes glk :: Primitives :: cube (); glk :: Primitives :: wire_cube (); // Solid and wire cones glk :: Primitives :: cone (); glk :: Primitives :: wire_cone (); // RGB-colored coordinate systems rendered using GL_LINES and polygons // They should be rendered with guik::VertexColor glk :: Primitives :: coordinate_system (); glk :: Primitives :: solid_coordinate_system (); // Wire frustum for representing a camera pose (+Z=front) glk :: Primitives :: wire_frustum (); Lines glk::ThinLines draws lines with GL_LINES. The thickness of lines is independent of the viewpoint. #include <glk/thin_lines.hpp> // Line vertices std :: vector < Eigen :: Vector3f > vertices = ...; // If line_strip == true, lines are drawn between adjacent vertices (GL_LINE_STRIP). // If line_strip == false, lines are drawn between vertices[i * 2] and vertices[i * 2 + 1] (GL_LINES). bool line_strip = true ; // Create lines (All vertices are processed in order) auto lines = std :: make_shared < glk :: ThinLines > ( vertices , line_strip ); // Create lines with indexing std :: vector < unsigned int > indices = ...; auto lines_with_indices = std :: make_shared < glk :: ThinLines > ( vertices , indices , line_strip ); // Create lines with vertex colors std :: vector < Eigen :: Vector4f > colors = ...; auto lines_with_colors = std :: make_shared < glk :: ThinLines > ( vertices , colors , line_strip ); // Set line width (glLineWidth) lines -> set_line_width ( 2.0f ); glk::Lines draws lines with polygons. The thickness of lines changes depending on the viewpoint and perspective. #include <glk/thin_lines.hpp> float line_width = 0.1f ; std :: vector < Eigen :: Vector3f > vertices = ...; std :: vector < Eigen :: Vector4f > colors = ...; bool line_strip = true ; auto lines = std :: make_shared < glk :: Lines > ( line_width , vertices , colors , line_strip ); Point cloud glk::PointCloudBuffer holds and renders a 3D point cloud. #include <glk/pointcloud_buffer.hpp> // Create PointCloudBuffer from std::vector<Eigen::Vector3f> std :: vector < Eigen :: Vector3f > vertices = ...; auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( vertices ); // Add vertex colors std :: vector < Eigen :: Vector4f > colors = ...; cloud_buffer -> add_color ( colors ); // Add vertex colors that encode scalar values in [0, 1] std :: vector < double > intensities = ...; cloud_buffer -> add_intensity ( glk :: COLORMAP :: TURBO , intensities ); // Add vertex normals std :: vector < Eigen :: Vector3f > normals = ...; cloud_buffer -> add_normals ( normals ); // Add AUX point property std :: vector < float > values = ...; int dim = 1 ; cloud_buffer -> add_buffer ( \"radius\" , dim , values . data (), sizeof ( float ) * dim , values . size ()); // Enlarge point size auto shader_setting = guik :: Rainbow (). set_point_scale ( 2.0f ); viewer -> update_drawable ( \"points\" , cloud_buffer , shader_setting ); glk::PointCloudBuffer rendered with guik::Rainbow glk::IndexedPointCloudBuffer enables specifying the indices of vertices to be rendered. #include <glk/indexed_pointcloud_buffer.hpp> std :: vector < Eigen :: Vector3f > vertices = ...; auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( vertices ); std :: vector < unsigned int > indices = ...; auto indexed_buffer = std :: make_shared < glk :: IndexedPointCloudBuffer > ( cloud_buffer , indices ); Point shape The point shape (rectangles by default) can be changed to circles by setting point_shape_mode=PointShapeMode::CIRCLE . auto viewer = guik :: viewer (); guik :: ShaderSetting & global_setting = viewer -> shader_setting (); global_setting . set_point_shape_mode ( guik :: PointShapeMode :: RECTANGLE ); // Set default point shape mode to RECTANGLE. Alternatively, global_setting.set_point_shape_rectangle() can be used. global_setting . set_point_shape_mode ( guik :: PointShapeMode :: CIRCLE ); // Set default point shape mode to CIRCLE. Alternatively, global_setting.set_point_shape_circle() can be used. Point scale Screen space scaling (default) The size of points is computed as radius_pix = point_scale * point_size * nz + point_size_offset , where nz is the fragment screen space depth in [0, 1]. By default point_scale=1.0 , point_size=10.0 , point_size_offset=0.0 , and they can be updated by setting values to guik::ShaderSetting . auto viewer = guik :: viewer (); guik :: ShaderSetting & global_setting = viewer -> shader_setting (); global_setting . set_point_scale_screenspace (); // Set the point scale mode to screenspace global_setting . set_point_size ( 5.0f ); // Set the base point size to 5.0 auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > (...); // Make the size of points as twice large as the base point size viewer -> update_drawable ( \"points\" , cloud_buffer , guik :: FlatBlue (). set_point_scale ( 2.0f )); Metric space scaling The size of points is computed based on the physical size specified as radius_m = point_scale * point_size + point_size_offset . auto viewer = guik :: viewer (); guik :: ShaderSetting & global_setting = viewer -> shader_setting (); global_setting . set_point_shape_circle (); global_setting . set_point_scale_metric (); global_setting . set_point_size ( 0.5f ); // Set default point radius to 0.5 auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > (...); // Set point radius to 0.5 viewer -> update_drawable ( \"points\" , cloud_buffer , guik :: FlatBlue (). set_point_size ( 0.5f )); Red : Wire spheres (radius=0.5), Blue : Points rendered with PointCloudBuffer ( point_shape_mode=CIRCLE , point_scale_mode=METRIC , point_size=0.5 ). Normal distributions glk::NormalDistributions #include <glk/normal_distributions.hpp> std :: vector < Eigen :: Vector3f > means = ...; std :: vector < Eigen :: Matrix3f > covs = ...; float scale = 1.0f ; auto normal_distributions = std :: make_shared < glk :: NormalDistributions > ( means , covs , scale ); Point splatting glk::Splatting #include <glk/splatting.hpp> // Create a PointCloudBuffer with normals std :: vector < Eigen :: Vector3f > vertices = ...; std :: vector < Eigen :: Vector3f > normals = ...; auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( vertices ); cloud_buffer -> add_normals ( normals ); // Create a splatting shader auto splatting_shader = glk :: create_splatting_shader (); // Create a splatting instance float point_radius = 0.1f ; auto splatting = std :: make_shared < glk :: Splatting > ( splatting_shader ); splatting -> set_point_radius ( point_radius ); splatting -> set_cloud_buffer ( cloud_buffer ); // If vertex radius is enabled, the radius of each point is calculated as point_radius * vertex's radius. // Otherwise, the fixed point_radius is used for rendering all points. splatting -> enable_vertex_radius (); std :: vector < float > radii = ...; cloud_buffer -> add_buffer ( \"radius\" , 1 , radii . data (), sizeof ( float ), radii . size ()); Sparse point cloud Sparse point cloud rendered using glk::Splatting Closer look at the splatting result: Points are rendered as oriented disks Mesh #include <glk/mesh.hpp> std :: vector < Eigen :: Vector3f > vertices = ...; std :: vector < Eigen :: Vector3f > normals = ...; std :: vector < Eigen :: Vector4f > colors = ...; std :: vector < Eigen :: Vector2f > tex_coords ; std :: vector < unsigned int > indices ; // Create a mesh instance // Pass nullptr if normal/color/tex_coord is not available auto mesh = std :: make_shared < glk :: Mesh > ( vertices . data (), sizeof ( float ) * 3 , normals . data (), sizeof ( float ) * 3 , colors . data (), sizeof ( float ) * 4 , tex_coords . data (), sizeof ( float ) * 2 , vertices . size () indices . data (), indices . size () ); std :: shared_ptr < glk :: Texture > texture = ...; mesh -> set_texture ( texture ); 2D Drawings guik::HoveredDrawings projects 3D object positions on the screen and draws 2D primitives on the projected positions. #include <guik/hovered_drawings.hpp> // Create hovered drawings renderer and register it to the viewer auto hovered = std :: make_shared < guik :: HoveredDrawings > (); viewer -> register_ui_callback ( \"hovered\" , hovered -> create_callback ()); // Draw a text at a fixed 3D position (1.0, 2.0, 3.0) std :: uint32_t fg_color = IM_COL32 ( 255 , 255 , 255 , 255 ); std :: uint32_t bg_color = IM_COL32 ( 0 , 0 , 0 , 128 ); hovered -> add_text ({ 1.0f , 2.0f , 3.0f }, \"text1\" , fg_color , bg_color ); // Instead of directly giving a 3D position, a drawable name can be // used to draw a 2D drawing on the drawable position hovered -> add_text_on ( \"drawable_name\" , \"text2\" , fg_color , bg_color ); // Cross Eigen :: Vector3f position = { 1.0f , 2.0f , 3.0f }; std :: uint32_t color = IM_COL32 ( 255 , 255 , 255 , 255 ); float size = 10.0f ; hovered -> add_cross ( position , color , size ); // Circle float radius = 10.0f ; hovered -> add_circle ( position , color , radius ); // Triangle float height = 20.0f ; hovered -> add_triangle ( position , color , height ); hovered -> add_filled_triangle ( position , color , height ); // Rectangle Eigen :: Vector2f size = { 10.0f , 10.0f }; Eigen :: Vector2f offset = { 0.0f , 0.0f }; hovered -> add_rect ( position , color , size , offset ); hovered -> add_filled_rect ( position , color , size , offset ); // Image (glk::Texture) std :: make_shared < glk :: Texture > texture = ...; hovered -> add_image ( position , texture , size , offset ); guik::HoveredDrawings can be drawn on subviewers. auto sub = viewer -> sub_viewer ( \"sub\" ); auto hovered = std :: make_shared < guik :: HoveredDrawings > ( sub ); hovered -> add_rect_on ( \"coord\" , IM_COL32 ( 0 , 255 , 0 , 255 )); sub -> register_ui_callback ( \"hovered\" , hovered -> create_callback ()); Image (2D texture) #include <glk/texture.hpp> // Create a texture from raw pixel data Eigen :: Vector2i size = ...; GLuint internal_format = GL_RGBA ; GLuint format = GL_RGB ; GLuint type = GL_UNSIGNED_BYTE ; std :: vector < unsigned char > pixels = ...; auto texture = std :: make_shared < glk :: Texture > ( size , internal_format , format , type , pixels . data ()); // Register the image to the viewer viewer -> update_image ( \"image\" , texture ); There is also a utility function to create a texture from cv::Mat . #include <glk/texture_opencv.hpp> cv :: Mat image = ...; auto texture = glk :: create_texture ( image ); viewer -> update_image ( \"image\" , texture ); If an image name contains '/', the string before the slash is recognized as a group name, and images with the same group name are grouped in a tab. viewer -> update_image ( \"group0/image0\" , texture ); viewer -> update_image ( \"group0/image1\" , texture ); viewer -> update_image ( \"group1/image0\" , texture ); Plots (ImPlot) #include <implot.h> #include <guik/viewer/light_viewer.hpp> std :: vector < double > xs = ...; std :: vector < double > ys = ...; // Basic plotting viewer -> setup_plot ( \"curves_y\" , 1024 , 256 ); viewer -> update_plot_line ( \"curves_y\" , \"sin\" , ys_sin ); // When only Y values are given, X values become index IDs viewer -> update_plot_stairs ( \"curves_y\" , \"sin_stairs\" , ys_sin ); std :: vector < double > xs_circle = ...; std :: vector < double > ys_circle = ...; // If a plot name contains \"/\", the string before the slash is recognized as a group name. // Plots with the same group name are displayed in the same tab. viewer -> setup_plot ( \"group02/circle\" , 1024 , 1024 , ImPlotFlags_Equal ); viewer -> update_plot_line ( \"group02/circle\" , \"circle\" , xs_circle , ys_circle , ImPlotLineFlags_Loop );","title":"Drawables"},{"location":"drawables/#drawables","text":"Examples of lines, 3D primitives, and 2D drawings ( Code ):","title":"Drawables"},{"location":"drawables/#shorthand-methods","text":"For frequently used drawable types, guik::LightViewer provides shorthand methods to quickly create and update drawables. // Primitives viewer -> update_sphere ( \"sphere\" , guik :: FlatRed ()); viewer -> update_wire_sphere ( \"wire_sphere\" , guik :: FlatRed ()); viewer -> update_coord ( \"coord\" , guik :: VertexColor ()); viewer -> update_wire_frustum ( \"frustum\" , guik :: FlatGreen ()); // PointCloudBuffer // Any of Vector(3|4)(f|d) are allowed as input std :: vector < Eigen :: Vector4d > points = ...; viewer -> update_points ( \"points\" , points , guik :: Rainbow ()); // NormalDistributions std :: vector < Eigen :: Vector3f > means = ...; std :: vector < Eigen :: Matrix3f > covs = ...; float scale = 1.0f ; viewer -> update_normal_dists ( \"normal_dists\" , means , covs , scale , guik :: Rainbow ());) // ThinLine std :: vector < Eigen :: Vector3f > line_vertices = ...; bool line_strip = true ; viewer -> update_thin_lines ( \"lines\" , line_vertices , true , guik :: FlatGreen ());","title":"Shorthand methods"},{"location":"drawables/#3d-primitives","text":"Icosahedron Sphere Stanford bunny Cube Cone Coordinate system Frustum #include <glk/primitives/primitives.hpp> // Solid and wire icosahedrons glk :: Primitives :: icosahedron (); glk :: Primitives :: wire_icosahedron (); // Solid and wire spheres glk :: Primitives :: sphere (); glk :: Primitives :: wire_sphere (); // Solid and wire bunnies glk :: Primitives :: bunny (); glk :: Primitives :: wire_bunny (); // Solid and wire cubes glk :: Primitives :: cube (); glk :: Primitives :: wire_cube (); // Solid and wire cones glk :: Primitives :: cone (); glk :: Primitives :: wire_cone (); // RGB-colored coordinate systems rendered using GL_LINES and polygons // They should be rendered with guik::VertexColor glk :: Primitives :: coordinate_system (); glk :: Primitives :: solid_coordinate_system (); // Wire frustum for representing a camera pose (+Z=front) glk :: Primitives :: wire_frustum ();","title":"3D Primitives"},{"location":"drawables/#lines","text":"glk::ThinLines draws lines with GL_LINES. The thickness of lines is independent of the viewpoint. #include <glk/thin_lines.hpp> // Line vertices std :: vector < Eigen :: Vector3f > vertices = ...; // If line_strip == true, lines are drawn between adjacent vertices (GL_LINE_STRIP). // If line_strip == false, lines are drawn between vertices[i * 2] and vertices[i * 2 + 1] (GL_LINES). bool line_strip = true ; // Create lines (All vertices are processed in order) auto lines = std :: make_shared < glk :: ThinLines > ( vertices , line_strip ); // Create lines with indexing std :: vector < unsigned int > indices = ...; auto lines_with_indices = std :: make_shared < glk :: ThinLines > ( vertices , indices , line_strip ); // Create lines with vertex colors std :: vector < Eigen :: Vector4f > colors = ...; auto lines_with_colors = std :: make_shared < glk :: ThinLines > ( vertices , colors , line_strip ); // Set line width (glLineWidth) lines -> set_line_width ( 2.0f ); glk::Lines draws lines with polygons. The thickness of lines changes depending on the viewpoint and perspective. #include <glk/thin_lines.hpp> float line_width = 0.1f ; std :: vector < Eigen :: Vector3f > vertices = ...; std :: vector < Eigen :: Vector4f > colors = ...; bool line_strip = true ; auto lines = std :: make_shared < glk :: Lines > ( line_width , vertices , colors , line_strip );","title":"Lines"},{"location":"drawables/#point-cloud","text":"glk::PointCloudBuffer holds and renders a 3D point cloud. #include <glk/pointcloud_buffer.hpp> // Create PointCloudBuffer from std::vector<Eigen::Vector3f> std :: vector < Eigen :: Vector3f > vertices = ...; auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( vertices ); // Add vertex colors std :: vector < Eigen :: Vector4f > colors = ...; cloud_buffer -> add_color ( colors ); // Add vertex colors that encode scalar values in [0, 1] std :: vector < double > intensities = ...; cloud_buffer -> add_intensity ( glk :: COLORMAP :: TURBO , intensities ); // Add vertex normals std :: vector < Eigen :: Vector3f > normals = ...; cloud_buffer -> add_normals ( normals ); // Add AUX point property std :: vector < float > values = ...; int dim = 1 ; cloud_buffer -> add_buffer ( \"radius\" , dim , values . data (), sizeof ( float ) * dim , values . size ()); // Enlarge point size auto shader_setting = guik :: Rainbow (). set_point_scale ( 2.0f ); viewer -> update_drawable ( \"points\" , cloud_buffer , shader_setting ); glk::PointCloudBuffer rendered with guik::Rainbow glk::IndexedPointCloudBuffer enables specifying the indices of vertices to be rendered. #include <glk/indexed_pointcloud_buffer.hpp> std :: vector < Eigen :: Vector3f > vertices = ...; auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( vertices ); std :: vector < unsigned int > indices = ...; auto indexed_buffer = std :: make_shared < glk :: IndexedPointCloudBuffer > ( cloud_buffer , indices );","title":"Point cloud"},{"location":"drawables/#point-shape","text":"The point shape (rectangles by default) can be changed to circles by setting point_shape_mode=PointShapeMode::CIRCLE . auto viewer = guik :: viewer (); guik :: ShaderSetting & global_setting = viewer -> shader_setting (); global_setting . set_point_shape_mode ( guik :: PointShapeMode :: RECTANGLE ); // Set default point shape mode to RECTANGLE. Alternatively, global_setting.set_point_shape_rectangle() can be used. global_setting . set_point_shape_mode ( guik :: PointShapeMode :: CIRCLE ); // Set default point shape mode to CIRCLE. Alternatively, global_setting.set_point_shape_circle() can be used.","title":"Point shape"},{"location":"drawables/#point-scale","text":"Screen space scaling (default) The size of points is computed as radius_pix = point_scale * point_size * nz + point_size_offset , where nz is the fragment screen space depth in [0, 1]. By default point_scale=1.0 , point_size=10.0 , point_size_offset=0.0 , and they can be updated by setting values to guik::ShaderSetting . auto viewer = guik :: viewer (); guik :: ShaderSetting & global_setting = viewer -> shader_setting (); global_setting . set_point_scale_screenspace (); // Set the point scale mode to screenspace global_setting . set_point_size ( 5.0f ); // Set the base point size to 5.0 auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > (...); // Make the size of points as twice large as the base point size viewer -> update_drawable ( \"points\" , cloud_buffer , guik :: FlatBlue (). set_point_scale ( 2.0f )); Metric space scaling The size of points is computed based on the physical size specified as radius_m = point_scale * point_size + point_size_offset . auto viewer = guik :: viewer (); guik :: ShaderSetting & global_setting = viewer -> shader_setting (); global_setting . set_point_shape_circle (); global_setting . set_point_scale_metric (); global_setting . set_point_size ( 0.5f ); // Set default point radius to 0.5 auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > (...); // Set point radius to 0.5 viewer -> update_drawable ( \"points\" , cloud_buffer , guik :: FlatBlue (). set_point_size ( 0.5f )); Red : Wire spheres (radius=0.5), Blue : Points rendered with PointCloudBuffer ( point_shape_mode=CIRCLE , point_scale_mode=METRIC , point_size=0.5 ).","title":"Point scale"},{"location":"drawables/#normal-distributions","text":"glk::NormalDistributions #include <glk/normal_distributions.hpp> std :: vector < Eigen :: Vector3f > means = ...; std :: vector < Eigen :: Matrix3f > covs = ...; float scale = 1.0f ; auto normal_distributions = std :: make_shared < glk :: NormalDistributions > ( means , covs , scale );","title":"Normal distributions"},{"location":"drawables/#point-splatting","text":"glk::Splatting #include <glk/splatting.hpp> // Create a PointCloudBuffer with normals std :: vector < Eigen :: Vector3f > vertices = ...; std :: vector < Eigen :: Vector3f > normals = ...; auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( vertices ); cloud_buffer -> add_normals ( normals ); // Create a splatting shader auto splatting_shader = glk :: create_splatting_shader (); // Create a splatting instance float point_radius = 0.1f ; auto splatting = std :: make_shared < glk :: Splatting > ( splatting_shader ); splatting -> set_point_radius ( point_radius ); splatting -> set_cloud_buffer ( cloud_buffer ); // If vertex radius is enabled, the radius of each point is calculated as point_radius * vertex's radius. // Otherwise, the fixed point_radius is used for rendering all points. splatting -> enable_vertex_radius (); std :: vector < float > radii = ...; cloud_buffer -> add_buffer ( \"radius\" , 1 , radii . data (), sizeof ( float ), radii . size ()); Sparse point cloud Sparse point cloud rendered using glk::Splatting Closer look at the splatting result: Points are rendered as oriented disks","title":"Point splatting"},{"location":"drawables/#mesh","text":"#include <glk/mesh.hpp> std :: vector < Eigen :: Vector3f > vertices = ...; std :: vector < Eigen :: Vector3f > normals = ...; std :: vector < Eigen :: Vector4f > colors = ...; std :: vector < Eigen :: Vector2f > tex_coords ; std :: vector < unsigned int > indices ; // Create a mesh instance // Pass nullptr if normal/color/tex_coord is not available auto mesh = std :: make_shared < glk :: Mesh > ( vertices . data (), sizeof ( float ) * 3 , normals . data (), sizeof ( float ) * 3 , colors . data (), sizeof ( float ) * 4 , tex_coords . data (), sizeof ( float ) * 2 , vertices . size () indices . data (), indices . size () ); std :: shared_ptr < glk :: Texture > texture = ...; mesh -> set_texture ( texture );","title":"Mesh"},{"location":"drawables/#2d-drawings","text":"guik::HoveredDrawings projects 3D object positions on the screen and draws 2D primitives on the projected positions. #include <guik/hovered_drawings.hpp> // Create hovered drawings renderer and register it to the viewer auto hovered = std :: make_shared < guik :: HoveredDrawings > (); viewer -> register_ui_callback ( \"hovered\" , hovered -> create_callback ()); // Draw a text at a fixed 3D position (1.0, 2.0, 3.0) std :: uint32_t fg_color = IM_COL32 ( 255 , 255 , 255 , 255 ); std :: uint32_t bg_color = IM_COL32 ( 0 , 0 , 0 , 128 ); hovered -> add_text ({ 1.0f , 2.0f , 3.0f }, \"text1\" , fg_color , bg_color ); // Instead of directly giving a 3D position, a drawable name can be // used to draw a 2D drawing on the drawable position hovered -> add_text_on ( \"drawable_name\" , \"text2\" , fg_color , bg_color ); // Cross Eigen :: Vector3f position = { 1.0f , 2.0f , 3.0f }; std :: uint32_t color = IM_COL32 ( 255 , 255 , 255 , 255 ); float size = 10.0f ; hovered -> add_cross ( position , color , size ); // Circle float radius = 10.0f ; hovered -> add_circle ( position , color , radius ); // Triangle float height = 20.0f ; hovered -> add_triangle ( position , color , height ); hovered -> add_filled_triangle ( position , color , height ); // Rectangle Eigen :: Vector2f size = { 10.0f , 10.0f }; Eigen :: Vector2f offset = { 0.0f , 0.0f }; hovered -> add_rect ( position , color , size , offset ); hovered -> add_filled_rect ( position , color , size , offset ); // Image (glk::Texture) std :: make_shared < glk :: Texture > texture = ...; hovered -> add_image ( position , texture , size , offset ); guik::HoveredDrawings can be drawn on subviewers. auto sub = viewer -> sub_viewer ( \"sub\" ); auto hovered = std :: make_shared < guik :: HoveredDrawings > ( sub ); hovered -> add_rect_on ( \"coord\" , IM_COL32 ( 0 , 255 , 0 , 255 )); sub -> register_ui_callback ( \"hovered\" , hovered -> create_callback ());","title":"2D Drawings"},{"location":"drawables/#image-2d-texture","text":"#include <glk/texture.hpp> // Create a texture from raw pixel data Eigen :: Vector2i size = ...; GLuint internal_format = GL_RGBA ; GLuint format = GL_RGB ; GLuint type = GL_UNSIGNED_BYTE ; std :: vector < unsigned char > pixels = ...; auto texture = std :: make_shared < glk :: Texture > ( size , internal_format , format , type , pixels . data ()); // Register the image to the viewer viewer -> update_image ( \"image\" , texture ); There is also a utility function to create a texture from cv::Mat . #include <glk/texture_opencv.hpp> cv :: Mat image = ...; auto texture = glk :: create_texture ( image ); viewer -> update_image ( \"image\" , texture ); If an image name contains '/', the string before the slash is recognized as a group name, and images with the same group name are grouped in a tab. viewer -> update_image ( \"group0/image0\" , texture ); viewer -> update_image ( \"group0/image1\" , texture ); viewer -> update_image ( \"group1/image0\" , texture );","title":"Image (2D texture)"},{"location":"drawables/#plots-implot","text":"#include <implot.h> #include <guik/viewer/light_viewer.hpp> std :: vector < double > xs = ...; std :: vector < double > ys = ...; // Basic plotting viewer -> setup_plot ( \"curves_y\" , 1024 , 256 ); viewer -> update_plot_line ( \"curves_y\" , \"sin\" , ys_sin ); // When only Y values are given, X values become index IDs viewer -> update_plot_stairs ( \"curves_y\" , \"sin_stairs\" , ys_sin ); std :: vector < double > xs_circle = ...; std :: vector < double > ys_circle = ...; // If a plot name contains \"/\", the string before the slash is recognized as a group name. // Plots with the same group name are displayed in the same tab. viewer -> setup_plot ( \"group02/circle\" , 1024 , 1024 , ImPlotFlags_Equal ); viewer -> update_plot_line ( \"group02/circle\" , \"circle\" , xs_circle , ys_circle , ImPlotLineFlags_Loop );","title":"Plots (ImPlot)"},{"location":"effects/","text":"Screen space effect (Documentation unfinished) Screen space attribute estimation Input image without screen effects Naive screen space ambient occlusion #include <glk/effects/naive_screen_space_ambient_occlusion.hpp> auto ssao = std :: make_shared < glk :: NaiveScreenSpaceAmbientOcclusion > (); viewer -> set_screen_effect ( ssao ); Smoothed screen space ambient occlusion #include <glk/effects/screen_space_ambient_occlusion.hpp> auto ssao = std :: make_shared < glk :: ScreenSpaceAmbientOcclusion > (); viewer -> set_screen_effect ( ssao ); Screen space lighting #include <glk/effects/screen_space_lighting.hpp> Eigen :: Vector3f light0_pos ( 1.0f , 1.0f , 5.0f ); Eigen :: Vector4f light0_color ( 2.0f , 2.0f , 2.0f , 1.0f ); Eigen :: Vector3f light1_pos ( 0.0f , -2.0f , 2.0f ); Eigen :: Vector4f light1_color ( 0.5f , 0.5f , 0.5f , 1.0f ); auto lighting_effect = std :: make_shared < glk :: ScreenSpaceLighting > (); lighting_effect -> set_light ( 0 , light0_pos , light0_color ); lighting_effect -> set_light ( 1 , light1_pos , light1_color ); viewer -> enable_normal_buffer (); viewer -> set_screen_effect ( lighting_effect );","title":"Screen space effect"},{"location":"effects/#screen-space-effect","text":"(Documentation unfinished)","title":"Screen space effect"},{"location":"effects/#screen-space-attribute-estimation","text":"","title":"Screen space attribute estimation"},{"location":"effects/#input-image-without-screen-effects","text":"","title":"Input image without screen effects"},{"location":"effects/#naive-screen-space-ambient-occlusion","text":"#include <glk/effects/naive_screen_space_ambient_occlusion.hpp> auto ssao = std :: make_shared < glk :: NaiveScreenSpaceAmbientOcclusion > (); viewer -> set_screen_effect ( ssao );","title":"Naive screen space ambient occlusion"},{"location":"effects/#smoothed-screen-space-ambient-occlusion","text":"#include <glk/effects/screen_space_ambient_occlusion.hpp> auto ssao = std :: make_shared < glk :: ScreenSpaceAmbientOcclusion > (); viewer -> set_screen_effect ( ssao );","title":"Smoothed screen space ambient occlusion"},{"location":"effects/#screen-space-lighting","text":"#include <glk/effects/screen_space_lighting.hpp> Eigen :: Vector3f light0_pos ( 1.0f , 1.0f , 5.0f ); Eigen :: Vector4f light0_color ( 2.0f , 2.0f , 2.0f , 1.0f ); Eigen :: Vector3f light1_pos ( 0.0f , -2.0f , 2.0f ); Eigen :: Vector4f light1_color ( 0.5f , 0.5f , 0.5f , 1.0f ); auto lighting_effect = std :: make_shared < glk :: ScreenSpaceLighting > (); lighting_effect -> set_light ( 0 , light0_pos , light0_color ); lighting_effect -> set_light ( 1 , light1_pos , light1_color ); viewer -> enable_normal_buffer (); viewer -> set_screen_effect ( lighting_effect );","title":"Screen space lighting"},{"location":"misc/","text":"Miscellaneous Enabling/Disabling Vsync By default, vsync is enabled and the maximum FPS is limited to the refresh rate of the display. The maximum FPS can be unbounded by disabling vsync. // Disable vsync to unlimit the maximum FPS viewer -> disable_vsync (); // Enable vsync to limit the maximum FPS viewer -> enable_vsync (); Spin methods In addition to spin_once() and spin() , there are two utility methods for spinning the viewer, spin_until_click() and toggle_spin_once() that are useful for debugging. spin_until_click() spins the viewer until the break button gets clicked for step-by-step debugging. double angle = 0.0 ; while ( viewer -> spin_until_click ()) { viewer -> update_drawable ( \"cube\" , glk :: Primitives :: cube (), guik :: Rainbow (). rotate ( angle , { 0.0f , 0.0f , 1.0f })); angle += 0.1 ; } toggle_spin_once() spins the viewer and stops while the break checkbox is checked. double angle = 0.0 ; while ( viewer -> toggle_spin_once ()) { viewer -> update_drawable ( \"cube\" , glk :: Primitives :: cube (), guik :: Rainbow (). rotate ( angle , { 0.0f , 0.0f , 1.0f })); angle += 0.01 ; } Background color/image // Change the background color viewer -> set_clear_color ({ 0.2f , 0.2f , 0.2f , 1.0f }); // Set a background image std :: shared_ptr < glk :: Texture > texture = ...; viewer -> set_bg_texture ( texture ); Text output viewer -> append_text ( \"text1\" ); viewer -> append_text ( \"text2\" ); Removing drawables // Remove a drawable with a specified name viewer -> remove_drawable ( \"drawable_name\" ); // Removes drawables with names that match a regex pattern viewer -> remove_drawable ( std :: regex ( \"drawable_.+\" )); // Remove all drawables viewer -> clear_drawables (); Drawable filter viewer -> register_drawable_filter ( \"filter\" , []( const std :: string & drawable_name ) { bool do_rendering = true ; if ( drawable_name == \"drawable_to_be_filtered\" ) { do_rendering = false ; } return do_rendering ; }); // Drawable filter can be removed by overwriting with 0 viewer -> register_drawable_filter ( \"filter\" , 0 ); Changing the coloring settings of the Rainbow scheme glk :: COLORMAP colormap = glk :: COLORMAP :: AUTUMN ; // Colormap type Eigen :: Vector2f range ( -3.0f , 5.0f ); // Coloring range Eigen :: Vector3f axis ( 1.0f , 0.0f , 0.0f ); // Coloring axis viewer -> set_colormap ( colormap ); viewer -> shader_setting (). add ( \"z_range\" , range ); viewer -> shader_setting (). add ( \"colormap_axis\" , axis ); Colormaps #include <glk/colormap.hpp> // Get colormap value (integer version: value range = [0, 255]) Eigen :: Vector4i color = colormap ( glk :: COLORMAP :: TURBO , 128 ); // Get colormap value (float version: value range = [0.0, 1.0]) Eigen :: Vector4f colorf = colormapf ( glk :: COLORMAP :: TURBO , 0.5f ); // Get a caterogical color by evenly sampling colors from a colormap // The color loops every \"num_categories\" counts int count = 1 ; int num_categories = 16 ; Eigen :: Vector4i cat_color = colormap_categorical ( glk :: COLORMAP :: TURBO , count , num_categories ); // Float version Eigen :: Vector4f cat_colorf = colormap_categoricalf ( glk :: COLORMAP :: TURBO , count , num_categories ); Sub-viewer auto sub_viewer1 = viewer -> sub_viewer ( \"sub1\" ); sub_viewer1 -> update_drawable ( \"cube\" , glk :: Primitives :: cube (), guik :: Rainbow ()); auto sub_viewer2 = viewer -> sub_viewer ( \"sub2\" ); sub_viewer2 -> update_drawable ( \"sphere\" , glk :: Primitives :: sphere (), guik :: Rainbow ()); Sharing the default camera control with sub-viewers auto camera_control = viewer -> get_camera_control (); sub_viewer1 -> set_camera_control ( camera_control ); sub_viewer2 -> set_camera_control ( camera_control ); Taking screenshot Simple but slow screen capture methods (1~30 FPS): // 8-bit RGBA pixel data std :: vector < unsigned char > color_pixels = viewer -> read_color_buffer (); // float depth data std :: vector < float > depth_pixels = viewer -> read_depth_buffer (); For efficient asynchronous screen data transfer with pixel buffer objects (~500FPS), see src/example/ext_light_viewer_capture.cpp File dialogs (portable-file-dialogs) #include <portable-file-dialogs.h> #include <guik/recent_files.hpp> guik :: RecentFiles recent_files ( \"input_directory\" ); const std :: string path = pfd :: select_folder ( \"Select input directory\" , recent_files . most_recent ()). result (); if ( ! path . empty ()) { recent_files . push ( path ); } Logging (spdlog) #include <spdlog/spdlog.h> #include <spdlog/sinks/ringbuffer_sink.h> #include <guik/spdlog_sink.hpp> #include <guik/viewer/light_viewer.hpp> // Setup a ringbuffer sink for the default spdlog logger const int ringbuffer_size = 100 ; auto ringbuffer_sink = std :: make_shared < spdlog :: sinks :: ringbuffer_sink_mt > ( ringbuffer_size ); auto logger = spdlog :: default_logger (); logger -> sinks (). emplace_back ( ringbuffer_sink ); logger -> set_level ( spdlog :: level :: trace ); spdlog :: trace ( \"trace\" ); spdlog :: debug ( \"debug\" ); spdlog :: info ( \"info\" ); spdlog :: warn ( \"warning\" ); spdlog :: error ( \"error\" ); // Create a logger UI to display ringbuffer contents const double bg_alpha = 0.7 ; viewer -> register_ui_callback ( \"logging\" , guik :: create_logger_ui ( ringbuffer_sink , bg_alpha )); Image and 3D model IO PNG #include <glk/io/png_io.hpp> // Load PNG image // Pixel data are stored in 8-bit RGBA format int width , height ; std :: vector < unsigned char > pixels ; glk :: load_png ( \"image.png\" , width , height , pixels ); // Save image as a PNG image // Pixel data must be 8-bit RGBA glk :: save_png ( \"image.png\" , width , height , pixels ); JPEG #include <glk/io/jpeg_io.hpp> // Load JPEG image // Pixel data are stored in 8-bit RGBA format int width , height ; std :: vector < unsigned char > pixels ; glk :: load_jpeg ( \"image.png\" , width , height , pixels ); // Save image as a JPEG image // Pixel data must be 8-bit RGBA int quality = 100 ; glk :: save_jpeg ( \"image.png\" , width , height , pixels , quality ); PLY #include <glk/io/ply_io.hpp> // Load a PLY model auto ply = glk :: load_ply ( \"model.ply\" ); // ply->vertices : std::vector<Eigen::Vector3f> // ply->colors : std::vector<Eigen::Vector4f> // ply->normals : std::vector<Eigen::Vector3f> // ply->intensities : std::vector<float> // ply->indices : std::vector<int> // Save a PLY data glk :: save_ply_binary ( \"model.ply\" , * ply ); // Save a point cloud in the PLY format std :: vector < Eigen :: Vector3f > points glk :: save_ply_binary ( \"model.ply\" , points . data (), points . size ()); Viewer menu By pressing \"Ctrl+M\", a hidden menu bar appears. Via the manu bar, you can: Change the rainbow colormap, coloring axis and range Show an information window (FPS/CPU&GPU Usage) Enable/Disable vsync Enable/Disable XY grid Show drawable filter and editor Save/Load the camera setting Get 3D positions of objects via point picking Keyboard shortcut General Key Description Ctrl + M Show viewer menu Ctrl + J Save screenshot Ctrl + F Fit all plots to data Ctrl + MINUX / PLUS Increase / decrease point scale Camera control Key Description Ctrl + Arrow Move camera Ctrl + Page UP / Down Zoom in/out Ctrl + Home / End Increase / decrease moving speed (permanently) Shift Increase moving speed (while holding)","title":"Miscellaneous"},{"location":"misc/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"misc/#enablingdisabling-vsync","text":"By default, vsync is enabled and the maximum FPS is limited to the refresh rate of the display. The maximum FPS can be unbounded by disabling vsync. // Disable vsync to unlimit the maximum FPS viewer -> disable_vsync (); // Enable vsync to limit the maximum FPS viewer -> enable_vsync ();","title":"Enabling/Disabling Vsync"},{"location":"misc/#spin-methods","text":"In addition to spin_once() and spin() , there are two utility methods for spinning the viewer, spin_until_click() and toggle_spin_once() that are useful for debugging. spin_until_click() spins the viewer until the break button gets clicked for step-by-step debugging. double angle = 0.0 ; while ( viewer -> spin_until_click ()) { viewer -> update_drawable ( \"cube\" , glk :: Primitives :: cube (), guik :: Rainbow (). rotate ( angle , { 0.0f , 0.0f , 1.0f })); angle += 0.1 ; } toggle_spin_once() spins the viewer and stops while the break checkbox is checked. double angle = 0.0 ; while ( viewer -> toggle_spin_once ()) { viewer -> update_drawable ( \"cube\" , glk :: Primitives :: cube (), guik :: Rainbow (). rotate ( angle , { 0.0f , 0.0f , 1.0f })); angle += 0.01 ; }","title":"Spin methods"},{"location":"misc/#background-colorimage","text":"// Change the background color viewer -> set_clear_color ({ 0.2f , 0.2f , 0.2f , 1.0f }); // Set a background image std :: shared_ptr < glk :: Texture > texture = ...; viewer -> set_bg_texture ( texture );","title":"Background color/image"},{"location":"misc/#text-output","text":"viewer -> append_text ( \"text1\" ); viewer -> append_text ( \"text2\" );","title":"Text output"},{"location":"misc/#removing-drawables","text":"// Remove a drawable with a specified name viewer -> remove_drawable ( \"drawable_name\" ); // Removes drawables with names that match a regex pattern viewer -> remove_drawable ( std :: regex ( \"drawable_.+\" )); // Remove all drawables viewer -> clear_drawables ();","title":"Removing drawables"},{"location":"misc/#drawable-filter","text":"viewer -> register_drawable_filter ( \"filter\" , []( const std :: string & drawable_name ) { bool do_rendering = true ; if ( drawable_name == \"drawable_to_be_filtered\" ) { do_rendering = false ; } return do_rendering ; }); // Drawable filter can be removed by overwriting with 0 viewer -> register_drawable_filter ( \"filter\" , 0 );","title":"Drawable filter"},{"location":"misc/#changing-the-coloring-settings-of-the-rainbow-scheme","text":"glk :: COLORMAP colormap = glk :: COLORMAP :: AUTUMN ; // Colormap type Eigen :: Vector2f range ( -3.0f , 5.0f ); // Coloring range Eigen :: Vector3f axis ( 1.0f , 0.0f , 0.0f ); // Coloring axis viewer -> set_colormap ( colormap ); viewer -> shader_setting (). add ( \"z_range\" , range ); viewer -> shader_setting (). add ( \"colormap_axis\" , axis );","title":"Changing the coloring settings of the Rainbow scheme"},{"location":"misc/#colormaps","text":"#include <glk/colormap.hpp> // Get colormap value (integer version: value range = [0, 255]) Eigen :: Vector4i color = colormap ( glk :: COLORMAP :: TURBO , 128 ); // Get colormap value (float version: value range = [0.0, 1.0]) Eigen :: Vector4f colorf = colormapf ( glk :: COLORMAP :: TURBO , 0.5f ); // Get a caterogical color by evenly sampling colors from a colormap // The color loops every \"num_categories\" counts int count = 1 ; int num_categories = 16 ; Eigen :: Vector4i cat_color = colormap_categorical ( glk :: COLORMAP :: TURBO , count , num_categories ); // Float version Eigen :: Vector4f cat_colorf = colormap_categoricalf ( glk :: COLORMAP :: TURBO , count , num_categories );","title":"Colormaps"},{"location":"misc/#sub-viewer","text":"auto sub_viewer1 = viewer -> sub_viewer ( \"sub1\" ); sub_viewer1 -> update_drawable ( \"cube\" , glk :: Primitives :: cube (), guik :: Rainbow ()); auto sub_viewer2 = viewer -> sub_viewer ( \"sub2\" ); sub_viewer2 -> update_drawable ( \"sphere\" , glk :: Primitives :: sphere (), guik :: Rainbow ());","title":"Sub-viewer"},{"location":"misc/#sharing-the-default-camera-control-with-sub-viewers","text":"auto camera_control = viewer -> get_camera_control (); sub_viewer1 -> set_camera_control ( camera_control ); sub_viewer2 -> set_camera_control ( camera_control );","title":"Sharing the default camera control with sub-viewers"},{"location":"misc/#taking-screenshot","text":"Simple but slow screen capture methods (1~30 FPS): // 8-bit RGBA pixel data std :: vector < unsigned char > color_pixels = viewer -> read_color_buffer (); // float depth data std :: vector < float > depth_pixels = viewer -> read_depth_buffer (); For efficient asynchronous screen data transfer with pixel buffer objects (~500FPS), see src/example/ext_light_viewer_capture.cpp","title":"Taking screenshot"},{"location":"misc/#file-dialogs-portable-file-dialogs","text":"#include <portable-file-dialogs.h> #include <guik/recent_files.hpp> guik :: RecentFiles recent_files ( \"input_directory\" ); const std :: string path = pfd :: select_folder ( \"Select input directory\" , recent_files . most_recent ()). result (); if ( ! path . empty ()) { recent_files . push ( path ); }","title":"File dialogs (portable-file-dialogs)"},{"location":"misc/#logging-spdlog","text":"#include <spdlog/spdlog.h> #include <spdlog/sinks/ringbuffer_sink.h> #include <guik/spdlog_sink.hpp> #include <guik/viewer/light_viewer.hpp> // Setup a ringbuffer sink for the default spdlog logger const int ringbuffer_size = 100 ; auto ringbuffer_sink = std :: make_shared < spdlog :: sinks :: ringbuffer_sink_mt > ( ringbuffer_size ); auto logger = spdlog :: default_logger (); logger -> sinks (). emplace_back ( ringbuffer_sink ); logger -> set_level ( spdlog :: level :: trace ); spdlog :: trace ( \"trace\" ); spdlog :: debug ( \"debug\" ); spdlog :: info ( \"info\" ); spdlog :: warn ( \"warning\" ); spdlog :: error ( \"error\" ); // Create a logger UI to display ringbuffer contents const double bg_alpha = 0.7 ; viewer -> register_ui_callback ( \"logging\" , guik :: create_logger_ui ( ringbuffer_sink , bg_alpha ));","title":"Logging (spdlog)"},{"location":"misc/#image-and-3d-model-io","text":"","title":"Image and 3D model IO"},{"location":"misc/#png","text":"#include <glk/io/png_io.hpp> // Load PNG image // Pixel data are stored in 8-bit RGBA format int width , height ; std :: vector < unsigned char > pixels ; glk :: load_png ( \"image.png\" , width , height , pixels ); // Save image as a PNG image // Pixel data must be 8-bit RGBA glk :: save_png ( \"image.png\" , width , height , pixels );","title":"PNG"},{"location":"misc/#jpeg","text":"#include <glk/io/jpeg_io.hpp> // Load JPEG image // Pixel data are stored in 8-bit RGBA format int width , height ; std :: vector < unsigned char > pixels ; glk :: load_jpeg ( \"image.png\" , width , height , pixels ); // Save image as a JPEG image // Pixel data must be 8-bit RGBA int quality = 100 ; glk :: save_jpeg ( \"image.png\" , width , height , pixels , quality );","title":"JPEG"},{"location":"misc/#ply","text":"#include <glk/io/ply_io.hpp> // Load a PLY model auto ply = glk :: load_ply ( \"model.ply\" ); // ply->vertices : std::vector<Eigen::Vector3f> // ply->colors : std::vector<Eigen::Vector4f> // ply->normals : std::vector<Eigen::Vector3f> // ply->intensities : std::vector<float> // ply->indices : std::vector<int> // Save a PLY data glk :: save_ply_binary ( \"model.ply\" , * ply ); // Save a point cloud in the PLY format std :: vector < Eigen :: Vector3f > points glk :: save_ply_binary ( \"model.ply\" , points . data (), points . size ());","title":"PLY"},{"location":"misc/#viewer-menu","text":"By pressing \"Ctrl+M\", a hidden menu bar appears. Via the manu bar, you can: Change the rainbow colormap, coloring axis and range Show an information window (FPS/CPU&GPU Usage) Enable/Disable vsync Enable/Disable XY grid Show drawable filter and editor Save/Load the camera setting Get 3D positions of objects via point picking","title":"Viewer menu"},{"location":"misc/#keyboard-shortcut","text":"","title":"Keyboard shortcut"},{"location":"misc/#general","text":"Key Description Ctrl + M Show viewer menu Ctrl + J Save screenshot Ctrl + F Fit all plots to data Ctrl + MINUX / PLUS Increase / decrease point scale","title":"General"},{"location":"misc/#camera-control","text":"Key Description Ctrl + Arrow Move camera Ctrl + Page UP / Down Zoom in/out Ctrl + Home / End Increase / decrease moving speed (permanently) Shift Increase moving speed (while holding)","title":"Camera control"},{"location":"multithread/","text":"Multi-threading Invoke Because OpenGL commands can only be executed on a single GUI context thread, most of functionalities of Iridescence are also required to be executed on the single GUI thread. For safely updating visualization contents, Iridescence provides invoke() method that pushes a task (functor) to a thread-safe task queue and requests the viewer to execute it on the GUI thread. // This function is executed in a background thread void async_update () { for ( int i = 0 ; i < 100 ; i ++ ) { // Prepare point cloud data to be rendered std :: shared_ptr < std :: vector < Eigen :: Vector3f >> points = ...; // Creating a PointCloudBuffer here is not allowed because OpenGL objects // must be created in the thread where the OpenGL context was created. // // The following line does not work here!! // auto cloud_buffer = std::make_shared<glk::PointCloudBuffer>(*points); auto viewer = guik :: LightViewer :: instance (); // Requst the viewer to execute the following function in the GUI thread. viewer -> invoke ([ = ] { // This lambda function will be evaluated in the GUI thread lately. auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( * points ); viewer -> update_drawable ( \"poits\" , cloud_buffer , guik :: Rainbow ()); }); } } int main ( int argc , char ** argv ) { // OpenGL context is created on the thread where the first call of LightViewer::instance() was made. // We thus recommend calling it in the main thread before using any visualization operations. auto viewer = guik :: LightViewer :: instance (); std :: thread thread ( async_update ); viewer -> spin (); return 0 ; } Thread-safe operations append_text and clear_text are thread-safe. viewer -> append_text ( \"test\" ); viewer -> clear_text (); AsyncViewer If you want to keep the viewer interactive while your program is doing some blocking operations, guik::AsyncLightViewer would be helpful. This class creates the viewer instance in a background thread and performs visualization tasks in a way thread safe. See 06_light_viewer_async.cpp . #include <guik/viewer/async_light_viewer.hpp> int main ( int argc , char ** argv ) { // AsyncViewer creates and runs the viewer in a background thread. auto async_viewer = guik :: async_viewer (); // Use AsyncViewer interfaces for safe viewer data manipulation. // AsyncViewer will be kept interactive even while the main thread is sleeping. std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); async_viewer -> update_wire_sphere ( \"sphere1\" , guik :: FlatRed (). translate ( 0.0f , 0.0f , 0.0f )); std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); async_viewer -> update_wire_sphere ( \"sphere2\" , guik :: FlatGreen (). translate ( 2.0f , 0.0f , 0.0f )); // Wait for the viewer to be closed. guik :: async_wait (); } Warning Because AsyncViewer runs the viewer in a background thread, calling the standard viewer functions in this main thread is unsafe. auto async_viewer = guik :: async_viewer (); // The below line may cause segfaults and program crashes. // guik::viewer()->update_sphere(\"sphere0\", guik::FlatBlue());","title":"Multi-threading"},{"location":"multithread/#multi-threading","text":"","title":"Multi-threading"},{"location":"multithread/#invoke","text":"Because OpenGL commands can only be executed on a single GUI context thread, most of functionalities of Iridescence are also required to be executed on the single GUI thread. For safely updating visualization contents, Iridescence provides invoke() method that pushes a task (functor) to a thread-safe task queue and requests the viewer to execute it on the GUI thread. // This function is executed in a background thread void async_update () { for ( int i = 0 ; i < 100 ; i ++ ) { // Prepare point cloud data to be rendered std :: shared_ptr < std :: vector < Eigen :: Vector3f >> points = ...; // Creating a PointCloudBuffer here is not allowed because OpenGL objects // must be created in the thread where the OpenGL context was created. // // The following line does not work here!! // auto cloud_buffer = std::make_shared<glk::PointCloudBuffer>(*points); auto viewer = guik :: LightViewer :: instance (); // Requst the viewer to execute the following function in the GUI thread. viewer -> invoke ([ = ] { // This lambda function will be evaluated in the GUI thread lately. auto cloud_buffer = std :: make_shared < glk :: PointCloudBuffer > ( * points ); viewer -> update_drawable ( \"poits\" , cloud_buffer , guik :: Rainbow ()); }); } } int main ( int argc , char ** argv ) { // OpenGL context is created on the thread where the first call of LightViewer::instance() was made. // We thus recommend calling it in the main thread before using any visualization operations. auto viewer = guik :: LightViewer :: instance (); std :: thread thread ( async_update ); viewer -> spin (); return 0 ; }","title":"Invoke"},{"location":"multithread/#thread-safe-operations","text":"append_text and clear_text are thread-safe. viewer -> append_text ( \"test\" ); viewer -> clear_text ();","title":"Thread-safe operations"},{"location":"multithread/#asyncviewer","text":"If you want to keep the viewer interactive while your program is doing some blocking operations, guik::AsyncLightViewer would be helpful. This class creates the viewer instance in a background thread and performs visualization tasks in a way thread safe. See 06_light_viewer_async.cpp . #include <guik/viewer/async_light_viewer.hpp> int main ( int argc , char ** argv ) { // AsyncViewer creates and runs the viewer in a background thread. auto async_viewer = guik :: async_viewer (); // Use AsyncViewer interfaces for safe viewer data manipulation. // AsyncViewer will be kept interactive even while the main thread is sleeping. std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); async_viewer -> update_wire_sphere ( \"sphere1\" , guik :: FlatRed (). translate ( 0.0f , 0.0f , 0.0f )); std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); async_viewer -> update_wire_sphere ( \"sphere2\" , guik :: FlatGreen (). translate ( 2.0f , 0.0f , 0.0f )); // Wait for the viewer to be closed. guik :: async_wait (); } Warning Because AsyncViewer runs the viewer in a background thread, calling the standard viewer functions in this main thread is unsafe. auto async_viewer = guik :: async_viewer (); // The below line may cause segfaults and program crashes. // guik::viewer()->update_sphere(\"sphere0\", guik::FlatBlue());","title":"AsyncViewer"},{"location":"picking/","text":"Point picking Getting the clicked position viewer -> register_ui_callback ( \"ui\" , [ & ] { auto & io = ImGui :: GetIO (); // If right clicked the GL canvas if ( ! io . WantCaptureMouse && io . MouseClicked [ ImGuiMouseButton_Right ]) { // Pick the depth of the clicked pixel float depth = viewer -> pick_depth ({ io . MousePos . x , io . MousePos . y }); // If depth < 1.0f, the clicked pixel is a foreground object. Otherwise, it is the background. if ( depth < 1.0f ) { // Compute the 3D position of the clicked pixel Eigen :: Vector3f pos = viewer -> unproject ({ io . MousePos . x , io . MousePos . y }, depth ); viewer -> update_drawable ( \"sphere\" , glk :: Primitives :: sphere (), guik :: FlatRed (). translate ( pos ). scale ( 0.05 )); } } }); There is also a convenient method pick_point() that check if the clicked point has valid 3D coordinates. viewer -> register_ui_callback ( \"ui\" , [ & ] { int button = ImGuiMouseButton_Right ; std :: optional < Eigen :: Vector3f > pt = viewer -> pick_point ( button ); if ( pt ) { std :: cout << \"clicked point=\" << pt -> transpose () << std :: endl ; } } Getting the clicked object information // Enable information buffer viewer -> enable_info_buffer (); // Draw green and blue cubes with info_values == {1, 0, 0, 0} and {2, 0, 0, 0} respectively viewer -> update_drawable ( \"cube1\" , glk :: Primitives :: cube (), guik :: FlatGreen (). add ( \"info_values\" , Eigen :: Vector4i ( 1 , 0 , 0 , 0 ))); viewer -> update_drawable ( \"cube2\" , glk :: Primitives :: cube (), guik :: FlatBlue (). add ( \"info_values\" , Eigen :: Vector4i ( 2 , 0 , 0 , 0 )). translate ({ 2.0 , 0.0 , 0.0 })); viewer -> register_ui_callback ( \"ui\" , [ & ] { auto & io = ImGui :: GetIO (); if ( ! io . WantCaptureMouse && io . MouseClicked [ ImGuiMouseButton_Right ]) { float depth = viewer -> pick_depth ({ io . MousePos . x , io . MousePos . y }); // If the clicked pixel is a foreground object if ( depth < 1.0f ) { // Pick the info_values of the clicked pixel Eigen :: Vector4i info = viewer -> pick_info ({ io . MousePos . x , io . MousePos . y }); if ( info [ 0 ] == 1 ) { viewer -> append_text ( \"Green cube clicked!!\" ); } else if ( info [ 0 ] == 2 ) { viewer -> append_text ( \"Blue cube clicked!!\" ); } } } });","title":"Point picking"},{"location":"picking/#point-picking","text":"","title":"Point picking"},{"location":"picking/#getting-the-clicked-position","text":"viewer -> register_ui_callback ( \"ui\" , [ & ] { auto & io = ImGui :: GetIO (); // If right clicked the GL canvas if ( ! io . WantCaptureMouse && io . MouseClicked [ ImGuiMouseButton_Right ]) { // Pick the depth of the clicked pixel float depth = viewer -> pick_depth ({ io . MousePos . x , io . MousePos . y }); // If depth < 1.0f, the clicked pixel is a foreground object. Otherwise, it is the background. if ( depth < 1.0f ) { // Compute the 3D position of the clicked pixel Eigen :: Vector3f pos = viewer -> unproject ({ io . MousePos . x , io . MousePos . y }, depth ); viewer -> update_drawable ( \"sphere\" , glk :: Primitives :: sphere (), guik :: FlatRed (). translate ( pos ). scale ( 0.05 )); } } }); There is also a convenient method pick_point() that check if the clicked point has valid 3D coordinates. viewer -> register_ui_callback ( \"ui\" , [ & ] { int button = ImGuiMouseButton_Right ; std :: optional < Eigen :: Vector3f > pt = viewer -> pick_point ( button ); if ( pt ) { std :: cout << \"clicked point=\" << pt -> transpose () << std :: endl ; } }","title":"Getting the clicked position"},{"location":"picking/#getting-the-clicked-object-information","text":"// Enable information buffer viewer -> enable_info_buffer (); // Draw green and blue cubes with info_values == {1, 0, 0, 0} and {2, 0, 0, 0} respectively viewer -> update_drawable ( \"cube1\" , glk :: Primitives :: cube (), guik :: FlatGreen (). add ( \"info_values\" , Eigen :: Vector4i ( 1 , 0 , 0 , 0 ))); viewer -> update_drawable ( \"cube2\" , glk :: Primitives :: cube (), guik :: FlatBlue (). add ( \"info_values\" , Eigen :: Vector4i ( 2 , 0 , 0 , 0 )). translate ({ 2.0 , 0.0 , 0.0 })); viewer -> register_ui_callback ( \"ui\" , [ & ] { auto & io = ImGui :: GetIO (); if ( ! io . WantCaptureMouse && io . MouseClicked [ ImGuiMouseButton_Right ]) { float depth = viewer -> pick_depth ({ io . MousePos . x , io . MousePos . y }); // If the clicked pixel is a foreground object if ( depth < 1.0f ) { // Pick the info_values of the clicked pixel Eigen :: Vector4i info = viewer -> pick_info ({ io . MousePos . x , io . MousePos . y }); if ( info [ 0 ] == 1 ) { viewer -> append_text ( \"Green cube clicked!!\" ); } else if ( info [ 0 ] == 2 ) { viewer -> append_text ( \"Blue cube clicked!!\" ); } } } });","title":"Getting the clicked object information"},{"location":"shader/","text":"Shader setting Shader setting guik::ShaderSetting class holds rendering parameters of a drawable object (e.g., color mode and model matrix) to control the rendering process of the assigned object. // A sphere drawable object std :: shared_ptr < glk :: Drawable > drawable = glk :: Primitives :: sphere (); // guik::ShaderSetting holds rendering parameters int color_mode = glk :: ColorMode :: RAINBOW ; Eigen :: Matrix4f transformation = Eigen :: Matrix4f :: Identity (); auto shader_setting = guik :: ShaderSetting ( color_mode , transformation ) // Register the pair of drawable object and shader setting to the viewer viewer -> update_drawable ( \"drawable_name\" , drawable , shader_setting ); Transformation guik::ShaderSetting accepts Eigen transformations (e.g., Eigen::Matrix4f , Eigen::Isometry3f , Eigen::Affine3f and their double counterparts) as the model transformation. It also has several utility methods to manipulate the model matrix. The utility methods applies a transformation on the right side of the original model transformation. // The model matrix becomes Identity() * Rotation(3.14rad, (1,0,0)) * Translation(1,0,0) * Scale(0.1) viewer -> update_drawable ( \"drawable_name\" , drawable , guik :: Rainbow (). rotate ( 3.14f , { 1.0f , 0.0f , 0.0f }). translate ({ 1.0f , 0.0f , 0.0f }). scale ( 0.1f ) ); Coloring schemes There are four coloring schemes in Iridescence, and they have corresponding utility classes that are derived from guik::ShaderSetting : RAINBOW (guik::Rainbow) scheme draws pixels with colors that encode the 3D position of each pixel (By default, it encodes the height (z) position of each pixel). FLAT_COLOR (guik::FlatColor) scheme draws pixels with a flat color. VERTEX_COLOR (guik::VertexColor) scheme draws pixels with interpolated colors of corresponding vertices. TEXTURE_COLOR (guik::TextureColor) scheme samples pixel colors from a texture. Left to right: Rainbow, FlatColor, VertexColor, TextureColor (transparent) Eigen :: Matrix4f transformation = Eigen :: Matrix4f :: Identity (); // RAINBOW auto shader_setting = guik :: Rainbow ( transformation ); // FLAT_COLOR Eigen :: Vector4f color ( 1.0f , 0.5f , 0.0f , 1.0f ); auto shader_setting = guik :: FlatColor ( color , transformation ); // There are several flat color utility classes correspond to primitive colors // guik::FlatRed() == guik::FlatColor({1.0f, 0.0f, 0.0f, 1.0f}); // guik::FlatGreen() == guik::FlatColor({0.0f, 1.0f, 0.0f, 1.0f}); // guik::FlatBlue() == guik::FlatColor({0.0f, 0.0f, 1.0f, 1.0f}); // guik::FlatOrange() == guik::FlatColor({1.0f, 0.5f, 0.0f, 1.0f}); // VERTEX_COLOR auto shader_setting = guik :: VertexColor ( transformation ); // TEXTURE_COLOR with transparency auto shader_setting = guik :: TextureColor ( transformation ). make_transparent (); Example of point clouds rendered using the rainbow coloring scheme","title":"Shader setting"},{"location":"shader/#shader-setting","text":"","title":"Shader setting"},{"location":"shader/#shader-setting_1","text":"guik::ShaderSetting class holds rendering parameters of a drawable object (e.g., color mode and model matrix) to control the rendering process of the assigned object. // A sphere drawable object std :: shared_ptr < glk :: Drawable > drawable = glk :: Primitives :: sphere (); // guik::ShaderSetting holds rendering parameters int color_mode = glk :: ColorMode :: RAINBOW ; Eigen :: Matrix4f transformation = Eigen :: Matrix4f :: Identity (); auto shader_setting = guik :: ShaderSetting ( color_mode , transformation ) // Register the pair of drawable object and shader setting to the viewer viewer -> update_drawable ( \"drawable_name\" , drawable , shader_setting );","title":"Shader setting"},{"location":"shader/#transformation","text":"guik::ShaderSetting accepts Eigen transformations (e.g., Eigen::Matrix4f , Eigen::Isometry3f , Eigen::Affine3f and their double counterparts) as the model transformation. It also has several utility methods to manipulate the model matrix. The utility methods applies a transformation on the right side of the original model transformation. // The model matrix becomes Identity() * Rotation(3.14rad, (1,0,0)) * Translation(1,0,0) * Scale(0.1) viewer -> update_drawable ( \"drawable_name\" , drawable , guik :: Rainbow (). rotate ( 3.14f , { 1.0f , 0.0f , 0.0f }). translate ({ 1.0f , 0.0f , 0.0f }). scale ( 0.1f ) );","title":"Transformation"},{"location":"shader/#coloring-schemes","text":"There are four coloring schemes in Iridescence, and they have corresponding utility classes that are derived from guik::ShaderSetting : RAINBOW (guik::Rainbow) scheme draws pixels with colors that encode the 3D position of each pixel (By default, it encodes the height (z) position of each pixel). FLAT_COLOR (guik::FlatColor) scheme draws pixels with a flat color. VERTEX_COLOR (guik::VertexColor) scheme draws pixels with interpolated colors of corresponding vertices. TEXTURE_COLOR (guik::TextureColor) scheme samples pixel colors from a texture. Left to right: Rainbow, FlatColor, VertexColor, TextureColor (transparent) Eigen :: Matrix4f transformation = Eigen :: Matrix4f :: Identity (); // RAINBOW auto shader_setting = guik :: Rainbow ( transformation ); // FLAT_COLOR Eigen :: Vector4f color ( 1.0f , 0.5f , 0.0f , 1.0f ); auto shader_setting = guik :: FlatColor ( color , transformation ); // There are several flat color utility classes correspond to primitive colors // guik::FlatRed() == guik::FlatColor({1.0f, 0.0f, 0.0f, 1.0f}); // guik::FlatGreen() == guik::FlatColor({0.0f, 1.0f, 0.0f, 1.0f}); // guik::FlatBlue() == guik::FlatColor({0.0f, 0.0f, 1.0f, 1.0f}); // guik::FlatOrange() == guik::FlatColor({1.0f, 0.5f, 0.0f, 1.0f}); // VERTEX_COLOR auto shader_setting = guik :: VertexColor ( transformation ); // TEXTURE_COLOR with transparency auto shader_setting = guik :: TextureColor ( transformation ). make_transparent (); Example of point clouds rendered using the rainbow coloring scheme","title":"Coloring schemes"}]}